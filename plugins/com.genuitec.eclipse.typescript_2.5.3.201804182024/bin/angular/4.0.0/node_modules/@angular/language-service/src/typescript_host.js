"use strict";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var extras_1 = require("./extras");
var compiler_1 = require("@angular/compiler");
var compiler_cli_1 = require("@angular/compiler-cli");
var core_1 = require("@angular/core");
var ts = require("typescript");
var path = require("path");
var language_service_1 = require("./language_service");
var reflector_host_1 = require("./reflector_host");
var types_1 = require("./types");
var separator = '/';
/**
 * Create a `LanguageServiceHost`
 */
function createLanguageServiceFromTypescript(host, service, basePath) {
    var ngHost = new TypeScriptServiceHost(host, service, basePath);
    var ngServer = language_service_1.createLanguageService(ngHost);
    ngHost.setSite(ngServer);
    return ngServer;
}
exports.createLanguageServiceFromTypescript = createLanguageServiceFromTypescript;
/**
 * The language service never needs the normalized versions of the metadata. To avoid parsing
 * the content and resolving references, return an empty file. This also allows normalizing
 * template that are syntatically incorrect which is required to provide completions in
 * syntactically incorrect templates.
 */
var DummyHtmlParser = (function (_super) {
    __extends(DummyHtmlParser, _super);
    function DummyHtmlParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DummyHtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
        if (parseExpansionForms === void 0) { parseExpansionForms = false; }
        if (interpolationConfig === void 0) { interpolationConfig = compiler_1.DEFAULT_INTERPOLATION_CONFIG; }
        return new compiler_1.ParseTreeResult([], []);
    };
    return DummyHtmlParser;
}(compiler_1.HtmlParser));
exports.DummyHtmlParser = DummyHtmlParser;
/**
 * Avoid loading resources in the language servcie by using a dummy loader.
 */
var DummyResourceLoader = (function (_super) {
    __extends(DummyResourceLoader, _super);
    function DummyResourceLoader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DummyResourceLoader.prototype.get = function (url) { return Promise.resolve(''); };
    return DummyResourceLoader;
}(compiler_1.ResourceLoader));
exports.DummyResourceLoader = DummyResourceLoader;
/**
 * An implemntation of a `LanguageServiceHost` for a TypeScript project.
 *
 * The `TypeScriptServiceHost` implements the Angular `LanguageServiceHost` using
 * the TypeScript language services.
 *
 * @experimental
 */
var TypeScriptServiceHost = (function () {
    function TypeScriptServiceHost(host, tsService, basePath, logger) {
        this.host = host;
        this.tsService = tsService;
        this.basePath = basePath;
        this.logger = logger;
        this._staticSymbolCache = new compiler_1.StaticSymbolCache();
        this._typeCache = [];
        this.modulesOutOfDate = true;
        this.fileVersions = new Map();
    }
    TypeScriptServiceHost.prototype.setSite = function (service) { this.service = service; };
    TypeScriptServiceHost.prototype.updateProgram = function () {
        try {
            return Promise.resolve(this.updateProgramSync());
        }
        catch (e) {
            return Promise.reject(e);
        }
    };
    TypeScriptServiceHost.prototype.updateProgramSync = function () {
        return true;
    };
    Object.defineProperty(TypeScriptServiceHost.prototype, "resolver", {
        /**
         * Angular LanguageServiceHost implementation
         */
        get: function () {
            var _this = this;
            this.validate();
            var result = this._resolver;
            if (!result) {
                var moduleResolver = new compiler_1.NgModuleResolver(this.reflector);
                this._directiveResolver = new compiler_1.DirectiveResolver(this.reflector);
                var pipeResolver = new compiler_1.PipeResolver(this.reflector);
                var elementSchemaRegistry = new compiler_1.DomElementSchemaRegistry();
                var resourceLoader = new DummyResourceLoader();
                var urlResolver = compiler_1.createOfflineCompileUrlResolver();
                var htmlParser = new DummyHtmlParser();
                // This tracks the CompileConfig in codegen.ts. Currently these options
                // are hard-coded.
                var config = new compiler_1.CompilerConfig({ defaultEncapsulation: core_1.ViewEncapsulation.Emulated, useJit: false });
                var directiveNormalizer = new compiler_1.DirectiveNormalizer(resourceLoader, urlResolver, htmlParser, config);
                result = this._resolver = new compiler_1.CompileMetadataResolver(config, moduleResolver, this._directiveResolver, pipeResolver, new compiler_1.JitSummaryResolver(), elementSchemaRegistry, directiveNormalizer, new core_1.ÉµConsole(), this._staticSymbolCache, this.reflector, function (error, type) { return _this.collectError(error, type && type.filePath); });
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    TypeScriptServiceHost.prototype.getTemplateReferences = function () {
        this.ensureTemplateMap();
        return this.templateReferences || [];
    };
    TypeScriptServiceHost.prototype.isWithinInlineTemplate = function (sourceFile, position) {
        var node = TypeScriptServiceHost.findNode(sourceFile, position);
        if (node) {
            switch (node.kind) {
                case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
                case ts.SyntaxKind.StringLiteral:
                    var _a = TypeScriptServiceHost.getTemplateClassDeclFromNode(node), declaration = _a[0], decorator = _a[1];
                    var queryCache = undefined;
                    if (declaration && declaration.name) {
                        return true;
                    }
                    break;
            }
        }
        return false;
    };
    TypeScriptServiceHost.prototype.getTemplateAt = function (fileName, position) {
        var sourceFile = this.getSourceFile(fileName);
        if (sourceFile) {
            this.context = sourceFile.fileName;
            var node = TypeScriptServiceHost.findNode(sourceFile, position);
            if (node) {
                return this.getSourceFromNode(fileName, this.host.getScriptVersion(sourceFile.fileName), node);
            }
        }
        else {
            this.ensureTemplateMap();
            // TODO: Cannocalize the file?
            var componentType = this.fileToComponent.get(fileName);
            if (componentType) {
                return this.getSourceFromType(fileName, this.host.getScriptVersion(fileName), componentType);
            }
        }
        return undefined;
    };
    TypeScriptServiceHost.prototype.getAnalyzedModules = function () {
        this.validate();
        return this.ensureAnalyzedModules();
    };
    TypeScriptServiceHost.prototype.ensureAnalyzedModules = function () {
        var analyzedModules = this.analyzedModules;
        if (!analyzedModules) {
            var analyzeHost = { isSourceFile: function (filePath) { return true; } };
            var programSymbols = compiler_1.extractProgramSymbols(this.staticSymbolResolver, this.program.getSourceFiles().map(function (sf) { return sf.fileName; }), analyzeHost);
            analyzedModules = this.analyzedModules =
                compiler_1.analyzeNgModules(programSymbols, analyzeHost, this.resolver);
        }
        return analyzedModules;
    };
    TypeScriptServiceHost.prototype.getDiagnostics = function (fileName) {
        var _this = this;
        var source = this.getSourceFile(fileName);
        var declarations = this.getDeclarations(fileName);
        if (source && declarations) {
            return new extras_1.TypeScriptFileValidator(source, declarations, this.analyzedModules, this.host, this.basePath, function (directive) { return _this.reflector.componentModuleUrl(directive.type.reference); }, function (type) { return _this.getTemplateClassFromStaticSymbol(type); }).diagnostics();
        }
        return [];
    };
    TypeScriptServiceHost.prototype.prepareRefactoringChanges = function (projectName, type, files, parameters) {
        var _this = this;
        var changes = {};
        var refactoringDescription = "Update Angular Component references";
        try {
            if ((type === types_1.RefactoringType.RESOURCE_MOVE
                || type === types_1.RefactoringType.RESOURCE_RENAME)
                && parameters[types_1.RefactoringParameter.UPDATE_REFERENCES] === true) {
                this.updateAnalyzedModules();
                this.ensureAnalyzedModules();
                var this_1 = this;
                var sourceFiles = this.tsService.getProgram().getSourceFiles();
                var destination_1 = parameters[types_1.RefactoringParameter.DESTINATION];
                var moving_1 = type === types_1.RefactoringType.RESOURCE_MOVE;
                var posix_1 = path.posix;
                var urlResolver_1 = compiler_1.createOfflineCompileUrlResolver();
                var _loop_1 = function (source) {
                    if (isTypeScriptFile(source)) {
                        return "continue";
                    }
                    var isDir = isDirectory(source);
                    var source_Parsed = posix_1.parse(source);
                    var properties = getProperties(source);
                    sourceFiles.forEach(function (file) {
                        var fileName = file.fileName;
                        if (moving_1 && shouldIgnore(fileName)) {
                            // do not update files which are moved together - relative paths stay the same
                            return;
                        }
                        var file_Parsed = posix_1.parse(fileName);
                        var fileMeta = _this.analyzedModules.filesMap.get(fileName);
                        if (fileMeta && fileMeta.directives) {
                            var uniqueDirectives_1 = new Set();
                            fileMeta.directives.forEach(function (type) { return uniqueDirectives_1.add(type); });
                            uniqueDirectives_1.forEach(function (type) {
                                var nonNormalizedData = _this.resolver.getNonNormalizedDirectiveMetadata(type);
                                var directive = nonNormalizedData.metadata;
                                var declaration = this_1.getTemplateClassFromStaticSymbol(type);
                                var decorator = extras_1.findDecorator(directive, declaration);
                                if (directive && directive.isComponent && declaration && decorator && directive.template) {
                                    properties.forEach(function (property) {
                                        var propertyDeclaration = extras_1.findProperty(decorator, property);
                                        var node;
                                        if (propertyDeclaration && (node = propertyDeclaration.initializer)) {
                                            if (node.kind === ts.SyntaxKind.StringLiteral
                                                || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral) {
                                                prepareChanges(node);
                                            }
                                            else {
                                                if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {
                                                    var exp = node;
                                                    exp.elements.forEach(function (element) { return prepareChanges(element); });
                                                }
                                            }
                                        }
                                        function prepareChanges(node) {
                                            if (!node)
                                                return;
                                            if (node.kind !== ts.SyntaxKind.StringLiteral
                                                && node.kind !== ts.SyntaxKind.NoSubstitutionTemplateLiteral) {
                                                return;
                                            }
                                            var text = node.getText();
                                            if (!text)
                                                return;
                                            var url = stripQuotes(text);
                                            var urlPath = urlResolver_1.resolve(this_1.reflector.componentModuleUrl(directive.type.reference), url);
                                            var relative = correctPath(stripExt(path.relative(source_Parsed.dir, urlPath))); // find the relative path
                                            var normalize = correctPath(path.normalize(url));
                                            var canRefactor = isDir ? urlPath.includes(source) && normalize.endsWith(relative) : source === urlPath || (isTypeScriptFile(source) && posix_1.parse(source).name === posix_1.parse(urlPath).name);
                                            if (canRefactor) {
                                                var newText = destination_1;
                                                var start = node.getStart();
                                                var index = -1;
                                                var length_1 = 0;
                                                if (moving_1) {
                                                    index = text.indexOf(url);
                                                    newText = posix_1.relative(file_Parsed.dir, newText); // find relative path
                                                    length_1 = url.length - relative.length;
                                                    if (!newText.startsWith('.')) {
                                                        newText = '.' + separator + newText;
                                                    }
                                                    if (!newText.endsWith(separator)) {
                                                        newText = newText.concat(separator);
                                                    }
                                                }
                                                else {
                                                    length_1 = source_Parsed.name.length;
                                                    if (isDir) {
                                                        index = text.indexOf(relative);
                                                    }
                                                    else {
                                                        index = text.indexOf(source_Parsed.name);
                                                    }
                                                }
                                                if (index >= 0) {
                                                    start = start + index;
                                                    addChange(fileName, { span: { start: start, length: length_1 }, newText: newText }, changes);
                                                }
                                            }
                                        }
                                    });
                                }
                            });
                        }
                    });
                };
                for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                    var source = files_1[_i];
                    _loop_1(source);
                }
            }
        }
        catch (e) {
            if (this.logger) {
                this.logger.log(e);
            }
        }
        function shouldIgnore(fileName) {
            return !!files.find(function (file) {
                return file === fileName
                    || (file.endsWith("/") && fileName.startsWith(file));
            });
        }
        function getProperties(source) {
            // No need to check other file refactoring
            if (isHTMLFile(source)) {
                return ["templateUrl"];
            }
            else if (isCSSFile(source)) {
                return ["styleUrls"];
            }
            else if (isTypeScriptFile(source)) {
                return ["templateUrl", "styleUrls"]; // for ts files.
            }
            return [];
        }
        ;
        function correctPath(text) { return text.replace(/\\/g, separator); }
        function isDirectory(text) { return text.endsWith(separator); }
        function addChange(fileName, textChange, changes) {
            var fileChanges = changes[fileName] || (changes[fileName] = {});
            (fileChanges[refactoringDescription] || (fileChanges[refactoringDescription] = []))
                .push(textChange);
        }
        function isHTMLFile(fileName) {
            return fileName.endsWith(".html");
        }
        function isCSSFile(fileName) {
            return fileName.endsWith(".css") || fileName.endsWith(".scss") || fileName.endsWith(".sass");
        }
        function isTypeScriptFile(fileName) {
            return fileName.endsWith(".ts") || fileName.endsWith(".tsx");
        }
        function stripQuotes(text) {
            if (text.charAt(0) === '"' && text.charAt(text.length - 1) === '"') {
                return text.substr(1, text.length - 2);
            }
            else if (text.charAt(0) === '\'' && text.charAt(text.length - 1) === '\'') {
                return text.substr(1, text.length - 2);
            }
            return text;
        }
        function stripExt(name) {
            if (name.endsWith(".ts") || name.endsWith(".js")) {
                return name.substr(0, name.length - 3);
            }
            else if (name.endsWith(".tsx") || name.endsWith(".jsx")) {
                return name.substr(0, name.length - 4);
            }
            return name;
        }
        return changes;
    };
    TypeScriptServiceHost.prototype.getTemplates = function (fileName) {
        var _this = this;
        this.ensureTemplateMap();
        var componentType = this.fileToComponent.get(fileName);
        if (componentType) {
            var templateSource = this.getTemplateAt(fileName, 0);
            if (templateSource) {
                return [templateSource];
            }
        }
        else {
            var version_1 = this.host.getScriptVersion(fileName);
            var result_1 = [];
            var sourceFile_1 = this.getSourceFile(fileName);
            if (sourceFile_1) {
                this.context = sourceFile_1.path || sourceFile_1.fileName;
            }
            // Add all templates
            var fileMeta = this.analyzedModules.filesMap.get(fileName);
            if (fileMeta && fileMeta.directives) {
                var urlResolver_2 = compiler_1.createOfflineCompileUrlResolver();
                var uniqueDirectives_2 = new Set();
                fileMeta.directives.forEach(function (type) { return uniqueDirectives_2.add(type); });
                uniqueDirectives_2.forEach(function (type) {
                    var nonNormalizedData = _this.resolver.getNonNormalizedDirectiveMetadata(type);
                    var directive = nonNormalizedData.metadata;
                    var url;
                    var this_ = _this;
                    var declaration = _this.getTemplateClassFromStaticSymbol(type);
                    if (directive && directive.isComponent && directive.template && declaration) {
                        if ((url = directive.template.templateUrl)) {
                            //simple external template
                            addExternalTemplate(url, declaration, true);
                        }
                        else if (directive.template.template && directive.template.template.toLocaleLowerCase /*check if string */) {
                            //inline template
                            var decorator = extras_1.findDecorator(directive, declaration);
                            //template attribute
                            var templateAttr = extras_1.findProperty(decorator, "template");
                            if (templateAttr && templateAttr.initializer) {
                                var node = templateAttr.initializer;
                                switch (node.kind) {
                                    case ts.SyntaxKind.StringLiteral:
                                    case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
                                        var src = _this.getSourceFromDeclaration(fileName, version_1, _this.stringOf(node), shrink(spanOf(node)), _this.reflector.getStaticSymbol(sourceFile_1.fileName, declaration.name.text), declaration, node, declaration.getSourceFile());
                                        if (src) {
                                            result_1.push(src);
                                        }
                                        break;
                                }
                            }
                        }
                        else if (directive.template.template || directive.template.template === null) {
                            //maybe a TypeScript import style template
                            var decorator = extras_1.findDecorator(directive, declaration);
                            var url_1 = _this.findUrlForTsImportStyleTemplate(decorator);
                            if (url_1) {
                                addExternalTemplate(url_1, declaration, false);
                            }
                        }
                    }
                    return result_1;
                    function addExternalTemplate(url, declaration, checkAbsolute) {
                        //external template
                        var annotation = this_._directiveResolver.resolve(directive.type.reference);
                        var fileName = urlResolver_2.resolve(this_.reflector.componentModuleUrl(directive.type.reference), url);
                        var snapshot = this_.host.getScriptSnapshot(fileName);
                        if (checkAbsolute && !extras_1.isPresent(snapshot)) {
                            //try absolute path
                            fileName = urlResolver_2.resolve(this_.basePath + "/", url);
                            snapshot = this_.host.getScriptSnapshot(fileName);
                        }
                        if (snapshot) {
                            var source = snapshot.getText(0, snapshot.getLength());
                            var src = this_.getSourceFromDeclaration(fileName, version_1, source, { start: 0, end: source.length }, type, declaration, declaration, declaration.getSourceFile());
                            if (src) {
                                result_1.push(src);
                            }
                        }
                    }
                });
            }
            return result_1.length ? result_1 : undefined;
        }
    };
    TypeScriptServiceHost.prototype.findUrlForTsImportStyleTemplate = function (decorator) {
        //template attribute
        var templateAttr = extras_1.findProperty(decorator, "template");
        if (!templateAttr) {
            return null;
        }
        var type = undefined, symbol = undefined;
        try {
            if (templateAttr.initializer) {
                type = this.checker.getTypeAtLocation(templateAttr.initializer);
                symbol = this.checker.getSymbolAtLocation(templateAttr.initializer);
            }
            else {
                //support shorthand assignments 
                type = this.checker.getTypeAtLocation(templateAttr.name);
                symbol = this.checker.getShorthandAssignmentValueSymbol(templateAttr);
            }
        }
        catch (e) {
            //ignore - best effort
        }
        if (symbol && type
            && type.getFlags() === ts.TypeFlags.String
            && symbol.declarations && symbol.declarations.length == 1) {
            var decl = symbol.declarations[0];
            //declaration must be within import declaration
            var parent_1 = decl.parent;
            while (parent_1 && parent_1.kind !== ts.SyntaxKind.ImportDeclaration) {
                parent_1 = parent_1.parent;
            }
            if (parent_1) {
                var importDecl = parent_1;
                if (importDecl.moduleSpecifier.kind === ts.SyntaxKind.StringLiteral) {
                    var url = importDecl.moduleSpecifier.text;
                    if (url.endsWith(".html")) {
                        return url;
                    }
                }
            }
        }
        return null;
    };
    TypeScriptServiceHost.prototype.getDeclarations = function (fileName) {
        var _this = this;
        var result = [];
        var sourceFile = this.getSourceFile(fileName);
        if (sourceFile) {
            var visit_1 = function (child) {
                var declaration = _this.getDeclarationFromNode(sourceFile, child);
                if (declaration) {
                    result.push(declaration);
                }
                else {
                    ts.forEachChild(child, visit_1);
                }
            };
            ts.forEachChild(sourceFile, visit_1);
        }
        return result;
    };
    TypeScriptServiceHost.prototype.getSourceFile = function (fileName) {
        return this.tsService.getProgram().getSourceFile(fileName);
    };
    TypeScriptServiceHost.prototype.updateAnalyzedModules = function () {
        this.validate();
        if (this.modulesOutOfDate) {
            this.analyzedModules = null;
            this._reflector = null;
            this.templateReferences = null;
            this.fileToComponent = null;
            this.ensureAnalyzedModules();
            this.modulesOutOfDate = false;
        }
    };
    Object.defineProperty(TypeScriptServiceHost.prototype, "program", {
        get: function () { return this.tsService.getProgram(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeScriptServiceHost.prototype, "checker", {
        get: function () {
            var checker = this._checker;
            if (!checker) {
                checker = this._checker = this.program.getTypeChecker();
            }
            return checker;
        },
        enumerable: true,
        configurable: true
    });
    TypeScriptServiceHost.prototype.validate = function () {
        var _this = this;
        var program = this.program;
        if (this._staticSymbolResolver && this.lastProgram != program) {
            // Invalidate file that have changed in the static symbol resolver
            var invalidateFile = function (fileName) {
                return _this._staticSymbolResolver.invalidateFile(fileName);
            };
            this.clearCaches();
            var seen_1 = new Set();
            for (var _i = 0, _a = this.program.getSourceFiles(); _i < _a.length; _i++) {
                var sourceFile = _a[_i];
                var fileName = sourceFile.fileName;
                seen_1.add(fileName);
                var version = this.host.getScriptVersion(fileName);
                var lastVersion = this.fileVersions.get(fileName);
                if (version != lastVersion) {
                    this.fileVersions.set(fileName, version);
                    invalidateFile(fileName);
                }
            }
            // Remove file versions that are no longer in the file and invalidate them.
            var missing = Array.from(this.fileVersions.keys()).filter(function (f) { return !seen_1.has(f); });
            missing.forEach(function (f) { return _this.fileVersions.delete(f); });
            missing.forEach(invalidateFile);
            this.lastProgram = program;
        }
    };
    TypeScriptServiceHost.prototype.clearCaches = function () {
        this._checker = null;
        this._typeCache = [];
        this._resolver = null;
        this._directiveResolver = null;
        this.collectedErrors = null;
        this.modulesOutOfDate = true;
    };
    TypeScriptServiceHost.prototype.ensureTemplateMap = function () {
        this.updateAnalyzedModules();
        if (!this.fileToComponent || !this.templateReferences) {
            var fileToComponent = new Map();
            var templateReference = [];
            var ngModuleSummary = this.getAnalyzedModules();
            var urlResolver = compiler_1.createOfflineCompileUrlResolver();
            for (var _i = 0, _a = ngModuleSummary.ngModules; _i < _a.length; _i++) {
                var module_1 = _a[_i];
                for (var _b = 0, _c = module_1.declaredDirectives; _b < _c.length; _b++) {
                    var directive = _c[_b];
                    var metadata = this.resolver.getNonNormalizedDirectiveMetadata(directive.reference).metadata;
                    var moduleUri = this.reflector.componentModuleUrl(directive.reference);
                    if (metadata.isComponent && metadata.template) {
                        var templateUrl = null;
                        var tryAbsolute = false;
                        if (metadata.template.templateUrl
                            && moduleUri !== metadata.template.templateUrl) {
                            templateUrl = metadata.template.templateUrl;
                            tryAbsolute = true;
                        }
                        else if (!metadata.template.template || !metadata.template.template.toLocaleLowerCase) {
                            //maybe a TypeScript import style template
                            var declaration = this.getTemplateClassFromStaticSymbol(directive.reference);
                            var decorator = extras_1.findDecorator(metadata, declaration);
                            templateUrl = this.findUrlForTsImportStyleTemplate(decorator);
                        }
                        if (templateUrl) {
                            var templateName = urlResolver.resolve(moduleUri, templateUrl);
                            var snapshot = this.host.getScriptSnapshot(templateName);
                            if (!snapshot && tryAbsolute) {
                                templateName = urlResolver.resolve(this.basePath + "/", templateUrl);
                                snapshot = this.host.getScriptSnapshot(templateName);
                            }
                            if (snapshot) {
                                fileToComponent.set(templateName, directive.reference);
                                templateReference.push(templateName);
                            }
                        }
                    }
                }
            }
            this.fileToComponent = fileToComponent;
            this.templateReferences = templateReference;
        }
    };
    TypeScriptServiceHost.prototype.getSourceFromDeclaration = function (fileName, version, source, span, type, declaration, node, sourceFile) {
        var queryCache = undefined;
        var t = this;
        if (declaration) {
            return {
                fileName: fileName,
                version: version,
                source: source,
                span: span,
                type: type,
                get members() {
                    return compiler_cli_1.getClassMembersFromDeclaration(t.program, t.checker, sourceFile, declaration, t.tsService);
                },
                get query() {
                    if (!queryCache) {
                        var pipes_1 = t.service.getPipesAt(fileName, node.getStart());
                        queryCache = compiler_cli_1.getSymbolQuery(t.program, t.checker, sourceFile, function () { return compiler_cli_1.getPipesTable(sourceFile, t.program, t.checker, pipes_1, t.tsService); }, t.tsService);
                    }
                    return queryCache;
                }
            };
        }
    };
    TypeScriptServiceHost.prototype.getSourceFromNode = function (fileName, version, node) {
        var result = undefined;
        var t = this;
        switch (node.kind) {
            case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
            case ts.SyntaxKind.StringLiteral:
                var _a = TypeScriptServiceHost.getTemplateClassDeclFromNode(node), declaration = _a[0], decorator = _a[1];
                if (declaration && declaration.name) {
                    var sourceFile = this.getSourceFile(fileName);
                    return this.getSourceFromDeclaration(fileName, version, this.stringOf(node) || '', shrink(spanOf(node)), this.reflector.getStaticSymbol(sourceFile.fileName, declaration.name.text), declaration, node, sourceFile);
                }
                break;
        }
        return result;
    };
    TypeScriptServiceHost.prototype.getSourceFromType = function (fileName, version, type) {
        var result = undefined;
        var declaration = this.getTemplateClassFromStaticSymbol(type);
        if (declaration) {
            var snapshot = this.host.getScriptSnapshot(fileName);
            var source = snapshot.getText(0, snapshot.getLength());
            result = this.getSourceFromDeclaration(fileName, version, source, { start: 0, end: source.length }, type, declaration, declaration, declaration.getSourceFile());
        }
        return result;
    };
    Object.defineProperty(TypeScriptServiceHost.prototype, "reflectorHost", {
        get: function () {
            var _this = this;
            var result = this._reflectorHost;
            if (!result) {
                if (!this.context) {
                    // Make up a context by finding the first script and using that as the base dir.
                    this.context = this.host.getScriptFileNames()[0];
                }
                var basePath = this.basePath;
                var options = { basePath: basePath, genDir: basePath };
                var compilerOptions = this.host.getCompilationSettings();
                if (compilerOptions && compilerOptions.baseUrl) {
                    options.baseUrl = compilerOptions.baseUrl;
                }
                result = this._reflectorHost =
                    new reflector_host_1.ReflectorHost(function () { return _this.tsService.getProgram(); }, this.host, options);
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    TypeScriptServiceHost.prototype.collectError = function (error, filePath) {
        if (filePath) {
            var errorMap = this.collectedErrors;
            if (!errorMap || !this.collectedErrors) {
                errorMap = this.collectedErrors = new Map();
            }
            var errors = errorMap.get(filePath);
            if (!errors) {
                errors = [];
                this.collectedErrors.set(filePath, errors);
            }
            errors.push(error);
        }
    };
    Object.defineProperty(TypeScriptServiceHost.prototype, "staticSymbolResolver", {
        get: function () {
            var _this = this;
            var result = this._staticSymbolResolver;
            if (!result) {
                this._summaryResolver = new compiler_1.AotSummaryResolver({
                    loadSummary: function (filePath) { return null; },
                    isSourceFile: function (sourceFilePath) { return true; },
                    getOutputFileName: function (sourceFilePath) { return sourceFilePath; }
                }, this._staticSymbolCache);
                result = this._staticSymbolResolver = new compiler_1.StaticSymbolResolver(this.reflectorHost, this._staticSymbolCache, this._summaryResolver, function (e, filePath) { return _this.collectError(e, filePath); });
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeScriptServiceHost.prototype, "reflector", {
        get: function () {
            var _this = this;
            var result = this._reflector;
            if (!result) {
                var ssr = this.staticSymbolResolver;
                result = this._reflector = new compiler_1.StaticReflector(this._summaryResolver, ssr, [], [], function (e, filePath) { return _this.collectError(e, filePath); });
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    TypeScriptServiceHost.prototype.getTemplateClassFromStaticSymbol = function (type) {
        if (!type.filePath) {
            return;
        }
        var source = this.getSourceFile(type.filePath);
        if (source) {
            var declarationNode = ts.forEachChild(source, function (child) {
                if (child.kind === ts.SyntaxKind.ClassDeclaration) {
                    var classDeclaration = child;
                    if (classDeclaration.name != null && classDeclaration.name.text === type.name) {
                        return classDeclaration;
                    }
                }
            });
            return declarationNode;
        }
        return undefined;
    };
    /**
     * Given a template string node, see if it is an Angular template string, and if so return the
     * containing class.
     */
    TypeScriptServiceHost.getTemplateClassDeclFromNode = function (currentToken) {
        // Verify we are in a 'template' property assignment, in an object literal, which is an call
        // arg, in a decorator
        var parentNode = currentToken.parent; // PropertyAssignment
        if (!parentNode) {
            return TypeScriptServiceHost.missingTemplate;
        }
        if (parentNode.kind !== ts.SyntaxKind.PropertyAssignment) {
            return TypeScriptServiceHost.missingTemplate;
        }
        else {
            // TODO: Is this different for a literal, i.e. a quoted property name like "template"?
            if (parentNode.name.text !== 'template') {
                return TypeScriptServiceHost.missingTemplate;
            }
        }
        parentNode = parentNode.parent; // ObjectLiteralExpression
        if (!parentNode || parentNode.kind !== ts.SyntaxKind.ObjectLiteralExpression) {
            return TypeScriptServiceHost.missingTemplate;
        }
        parentNode = parentNode.parent; // CallExpression
        if (!parentNode || parentNode.kind !== ts.SyntaxKind.CallExpression) {
            return TypeScriptServiceHost.missingTemplate;
        }
        var callTarget = parentNode.expression;
        //TODO piotr: validate that we are in @Component decorator
        var decorator = parentNode.parent; // Decorator
        if (!decorator || decorator.kind !== ts.SyntaxKind.Decorator) {
            return TypeScriptServiceHost.missingTemplate;
        }
        var declaration = decorator.parent; // ClassDeclaration
        if (!declaration || declaration.kind !== ts.SyntaxKind.ClassDeclaration) {
            return TypeScriptServiceHost.missingTemplate;
        }
        return [declaration, callTarget];
    };
    TypeScriptServiceHost.prototype.getCollectedErrors = function (defaultSpan, sourceFile) {
        var errors = (this.collectedErrors && this.collectedErrors.get(sourceFile.fileName));
        return (errors && errors.map(function (e) {
            return { message: e.message, span: spanAt(sourceFile, e.line, e.column) || defaultSpan };
        })) ||
            [];
    };
    TypeScriptServiceHost.prototype.getDeclarationFromNode = function (sourceFile, node) {
        if (node.kind == ts.SyntaxKind.ClassDeclaration && node.decorators &&
            node.name) {
            for (var _i = 0, _a = node.decorators; _i < _a.length; _i++) {
                var decorator = _a[_i];
                if (decorator.expression && decorator.expression.kind == ts.SyntaxKind.CallExpression) {
                    var classDeclaration = node;
                    if (classDeclaration.name) {
                        var call = decorator.expression;
                        var target = call.expression;
                        var type = this.checker.getTypeAtLocation(target);
                        if (type) {
                            var staticSymbol = this.reflector.getStaticSymbol(sourceFile.fileName, classDeclaration.name.text);
                            try {
                                if (this.resolver.isDirective(staticSymbol)) {
                                    var metadata = this.resolver.getNonNormalizedDirectiveMetadata(staticSymbol).metadata;
                                    var declarationSpan = spanOf(target);
                                    return {
                                        type: staticSymbol,
                                        declarationSpan: declarationSpan,
                                        metadata: metadata,
                                        errors: this.getCollectedErrors(declarationSpan, sourceFile)
                                    };
                                }
                            }
                            catch (e) {
                                if (e.message) {
                                    this.collectError(e, sourceFile.fileName);
                                    var declarationSpan = spanOf(target);
                                    return {
                                        type: staticSymbol,
                                        declarationSpan: declarationSpan,
                                        errors: this.getCollectedErrors(declarationSpan, sourceFile)
                                    };
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    TypeScriptServiceHost.prototype.stringOf = function (node) {
        switch (node.kind) {
            case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
                return node.text;
            case ts.SyntaxKind.StringLiteral:
                return node.text;
        }
    };
    TypeScriptServiceHost.findNode = function (sourceFile, position) {
        function find(node) {
            if (position >= node.getStart() && position < node.getEnd()) {
                return ts.forEachChild(node, find) || node;
            }
        }
        return find(sourceFile);
    };
    TypeScriptServiceHost.prototype.removeFileDuplicates = function (files) {
        var _this = this;
        var result = new Set();
        this.getAnalyzedModules();
        //first gather all supported TS files
        files.forEach(function (file) {
            if (_this.analyzedModules.filesMap.has(file)) {
                result.add(file);
            }
        });
        //add HTML template file if component TS file is not there
        this.ensureTemplateMap();
        files.forEach(function (file) {
            var type;
            if (type = _this.fileToComponent.get(file)) {
                if (!result.has(type.filePath)) {
                    result.add(file);
                }
            }
        });
        return result;
    };
    return TypeScriptServiceHost;
}());
TypeScriptServiceHost.missingTemplate = [undefined, undefined];
exports.TypeScriptServiceHost = TypeScriptServiceHost;
function spanOf(node) {
    return { start: node.getStart(), end: node.getEnd() };
}
function shrink(span, offset) {
    if (offset == null)
        offset = 1;
    return { start: span.start + offset, end: span.end - offset };
}
function spanAt(sourceFile, line, column) {
    if (line != null && column != null) {
        var position_1 = ts.getPositionOfLineAndCharacter(sourceFile, line, column);
        var findChild = function findChild(node) {
            if (node.kind > ts.SyntaxKind.LastToken && node.pos <= position_1 && node.end > position_1) {
                var betterNode = ts.forEachChild(node, findChild);
                return betterNode || node;
            }
        };
        var node = ts.forEachChild(sourceFile, findChild);
        if (node) {
            return { start: node.getStart(), end: node.getEnd() };
        }
    }
}
//# sourceMappingURL=typescript_host.js.map