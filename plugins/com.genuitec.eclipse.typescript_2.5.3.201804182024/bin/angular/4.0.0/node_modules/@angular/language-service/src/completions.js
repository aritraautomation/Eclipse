"use strict";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var compiler_1 = require("@angular/compiler");
var compiler_cli_1 = require("@angular/compiler-cli");
var expressions_1 = require("./expressions");
var html_info_1 = require("./html_info");
var utils_1 = require("./utils");
var TEMPLATE_ATTR_PREFIX = '*';
var hiddenHtmlElements = {
    html: true,
    script: true,
    noscript: true,
    base: true,
    body: true,
    title: true,
    head: true,
    link: true,
};
function getTemplateCompletionEntryDetails(templateInfo, name, kind) {
    switch (kind) {
        case "pipe":
            var pipes = templateInfo.template.query.getPipes();
            if (pipes) {
                var symbol = pipes.get(name);
                return symbol && symbol.documentation;
            }
            break;
        case 'component':
            var component = templateInfo.directives.find(function (value) { return value.selector === name; });
            if (component) {
                var info = templateInfo.template.query.getTypeSymbol(component.type.reference);
                return info ? info.documentation : undefined;
            }
            break;
        case 'directive property':
        case 'method':
        case 'property':
        case 'type':
        case 'variable':
            var result_1 = undefined;
            var htmlAst = templateInfo.htmlAst, templateAst = templateInfo.templateAst, template = templateInfo.template;
            // The templateNode starts at the delimiter character so we add 1 to skip it.
            var templatePosition_1 = templateInfo.position - template.span.start;
            var path_1 = compiler_1.findNode(htmlAst, templatePosition_1);
            var mostSpecific = path_1.tail;
            if (!path_1.empty && mostSpecific) {
                var astPosition = templatePosition_1 - mostSpecific.sourceSpan.start.offset;
                mostSpecific.visit({
                    visitElement: function (ast) {
                        var startTagSpan = utils_1.spanOf(ast.sourceSpan);
                        var tagLen = ast.name.length;
                        if (templatePosition_1 < startTagSpan.end) {
                            // We are in the attribute section of the element (but not in an attribute).
                            // Return the attribute documentation.
                            if (kind === "directive property") {
                                result_1 = attributeDocumentation(templateInfo, path_1, name, kind);
                            }
                        }
                    },
                    visitAttribute: function (ast) {
                        if (!ast.valueSpan || !utils_1.inSpan(templatePosition_1, utils_1.spanOf(ast.valueSpan))) {
                            // We are in the name of an attribute. Show attribute documentation.
                            if (kind === "directive property") {
                                result_1 = attributeDocumentation(templateInfo, path_1, name, kind);
                            }
                        }
                        else if (ast.valueSpan && utils_1.inSpan(templatePosition_1, utils_1.spanOf(ast.valueSpan))) {
                            result_1 = attributeValueDocumentation(templateInfo, templatePosition_1, ast, name, kind);
                        }
                    },
                    visitText: function (ast) {
                        //Check if we are within an interpolation expression
                        // Look for an interpolation in at the position.
                        var templatePath = utils_1.findTemplateAstAt(templateInfo.templateAst, templatePosition_1);
                        var mostSpecific = templatePath.tail;
                        if (mostSpecific) {
                            var dinfo_1 = utils_1.diagnosticInfoFromTemplateInfo(templateInfo);
                            var visitor = new ExpressionDocVisitor(templateInfo, templatePosition_1, name, kind, undefined, function () { return compiler_cli_1.getExpressionScope(dinfo_1, templatePath, false); });
                            mostSpecific.visit(visitor, null);
                            result_1 = visitor.docResult;
                        }
                    },
                    visitComment: function (ast) { },
                    visitExpansion: function (ast) { },
                    visitExpansionCase: function (ast) { }
                }, null);
            }
            return result_1;
    }
    return undefined;
}
exports.getTemplateCompletionEntryDetails = getTemplateCompletionEntryDetails;
function getTemplateCompletions(templateInfo) {
    var result = undefined;
    var htmlAst = templateInfo.htmlAst, templateAst = templateInfo.templateAst, template = templateInfo.template;
    // The templateNode starts at the delimiter character so we add 1 to skip it.
    if (templateInfo.position != null) {
        var templatePosition_2 = templateInfo.position - template.span.start;
        var path_2 = compiler_1.findNode(htmlAst, templatePosition_2);
        var mostSpecific = path_2.tail;
        if (path_2.empty || !mostSpecific) {
            result = elementCompletions(templateInfo, path_2);
        }
        else {
            var astPosition_1 = templatePosition_2 - mostSpecific.sourceSpan.start.offset;
            mostSpecific.visit({
                visitElement: function (ast) {
                    var startTagSpan = utils_1.spanOf(ast.sourceSpan);
                    var tagLen = ast.name.length;
                    if (templatePosition_2 <=
                        startTagSpan.start + tagLen + 1 /* 1 for the opening angle bracked */) {
                        // If we are in the tag then return the element completions.
                        result = elementCompletions(templateInfo, path_2);
                    }
                    else if (templatePosition_2 < startTagSpan.end) {
                        // We are in the attribute section of the element (but not in an attribute).
                        // Return the attribute completions.
                        result = attributeCompletions(templateInfo, path_2);
                    }
                },
                visitAttribute: function (ast) {
                    if (!ast.valueSpan || !utils_1.inSpan(templatePosition_2, utils_1.spanOf(ast.valueSpan))) {
                        // We are in the name of an attribute. Show attribute completions.
                        result = attributeCompletions(templateInfo, path_2);
                    }
                    else if (ast.valueSpan && utils_1.inSpan(templatePosition_2, utils_1.spanOf(ast.valueSpan))) {
                        result = attributeValueCompletions(templateInfo, templatePosition_2, ast);
                    }
                },
                visitText: function (ast) {
                    // Check if we are in a entity.
                    result = entityCompletions(getSourceText(template, utils_1.spanOf(ast)), astPosition_1);
                    if (result)
                        return result;
                    result = interpolationCompletions(templateInfo, templatePosition_2);
                    if (result)
                        return result;
                    var element = path_2.first(compiler_1.Element);
                    if (element) {
                        var definition = compiler_1.getHtmlTagDefinition(element.name);
                        if (definition.contentType === compiler_1.TagContentType.PARSABLE_DATA) {
                            result = voidElementAttributeCompletions(templateInfo, path_2);
                            if (!result) {
                                // If the element can hold content Show element completions.
                                result = elementCompletions(templateInfo, path_2);
                            }
                        }
                    }
                    else {
                        // If no element container, implies parsable data so show elements.
                        result = voidElementAttributeCompletions(templateInfo, path_2);
                        if (!result) {
                            result = elementCompletions(templateInfo, path_2);
                        }
                    }
                },
                visitComment: function (ast) { },
                visitExpansion: function (ast) { },
                visitExpansionCase: function (ast) { }
            }, null);
        }
    }
    return result;
}
exports.getTemplateCompletions = getTemplateCompletions;
function attributeCompletions(info, path) {
    var item = path.tail instanceof compiler_1.Element ? path.tail : path.parentOf(path.tail);
    if (item instanceof compiler_1.Element) {
        return attributeCompletionsForElement(info, item.name, item);
    }
    return undefined;
}
function attributeDocumentation(info, path, name, type) {
    var item = path.tail instanceof compiler_1.Element ? path.tail : path.parentOf(path.tail);
    var _a = utils_1.getSelectors(info), selectors = _a.selectors, selectorMap = _a.map;
    if (item instanceof compiler_1.Element && selectors) {
        var matcher = new compiler_1.SelectorMatcher();
        matcher.addSelectables(selectors);
        var elementSelector = createElementCssSelector(item);
        var result_2;
        matcher.match(elementSelector, function (selector) {
            if (result_2) {
                return;
            }
            var directive = selectorMap.get(selector);
            if (directive) {
                var arr = void 0;
                var name_ = name;
                if (name_.startsWith("(")) {
                    name_ = name_.substr(1, name.length - 2);
                    arr = directive.outputs;
                }
                if (name_.startsWith("[")) {
                    name_ = name_.substr(1, name.length - 2);
                    arr = directive.inputs;
                }
                if (arr) {
                    for (var _i = 0, _a = Object.keys(arr); _i < _a.length; _i++) {
                        var key = _a[_i];
                        if (arr[key] === name_) {
                            //we have a match
                            var symbol = info.template.query.getTypeSymbol(directive.type.reference);
                            if (symbol && symbol.members()) {
                                var prop = symbol.members().get(key);
                                if (prop) {
                                    result_2 = prop.documentation;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        });
        return result_2;
    }
}
function attributeCompletionsForElement(info, elementName, element) {
    var attributes = getAttributeInfosForElement(info, elementName, element);
    // Map all the attributes to a completion
    return attributes.map(function (attr) { return ({
        kind: attr.fromHtml
            ? ((attr.input || attr.output) ? 'html property' : 'html attribute')
            : 'directive property',
        name: nameOfAttr(attr),
        sort: attr.name
    }); });
}
function getAttributeInfosForElement(info, elementName, element) {
    var attributes = [];
    // Add html attributes
    var htmlAttributes = html_info_1.attributeNames(elementName) || [];
    if (htmlAttributes) {
        attributes.push.apply(attributes, htmlAttributes.map(function (name) { return ({ name: name, fromHtml: true }); }));
    }
    // Add DOM properties
    var htmlProperties = html_info_1.propertyNames(elementName);
    if (htmlProperties) {
        attributes.push.apply(attributes, htmlProperties.map(function (name) { return ({ name: name, fromHtml: true, input: true }); }));
    }
    // Add DOM events
    var htmlEvents = html_info_1.eventNames(elementName);
    if (htmlEvents) {
        attributes.push.apply(attributes, htmlEvents.map(function (name) { return ({ name: name, fromHtml: true, output: true }); }));
    }
    var _a = utils_1.getSelectors(info), selectors = _a.selectors, selectorMap = _a.map;
    var dir2InOuts = new Map();
    if (selectors && selectors.length) {
        // All the attributes that are selectable should be shown.
        var applicableSelectors = selectors.filter(function (selector) { return !selector.element || selector.element == elementName; });
        var selectorAndAttributeNames = applicableSelectors.map(function (selector) { return ({ selector: selector, attrs: selector.attrs.filter(function (a) { return !!a; }) }); });
        // Add all self-selectable attributes
        var attrs_1 = utils_1.flatten(selectorAndAttributeNames.map(function (selectorAndAttr) {
            var directive = selectorMap.get(selectorAndAttr.selector);
            var _a = getDirectiveInOuts(directive), inputs = _a.inputs, outputs = _a.outputs;
            var result = selectorAndAttr.attrs.map(function (name) { return ({ name: name, input: inputs.has(name), output: outputs.has(name) }); });
            return result;
        }));
        // Add template attribute if a directive contains a template reference
        selectorAndAttributeNames.forEach(function (selectorAndAttr) {
            var selector = selectorAndAttr.selector;
            var directive = selectorMap.get(selector);
            if (directive && utils_1.hasTemplateReference(directive.type) && selector.attrs.length &&
                selector.attrs[0]) {
                attrs_1.push({ name: selector.attrs[0], template: true });
            }
        });
        // All input and output properties of the matching directives should be added.
        if (element && element.directives) {
            //We have gotten ElementAst from TemplateAst instead of Element from HtmlAst.
            //This case happens when validating expressions; we can directly use all found directives
            var elAst = element;
            if (elAst.directives) {
                for (var _i = 0, _b = elAst.directives; _i < _b.length; _i++) {
                    var dir = _b[_i];
                    var directive = dir.directive;
                    if (directive) {
                        var _c = getDirectiveInOuts(directive), inputs = _c.inputs, outputs = _c.outputs;
                        inputs.forEach(function (name) { return attrs_1.push({ name: name, input: true }); });
                        outputs.forEach(function (name) { return attrs_1.push({ name: name, output: true }); });
                        if (directive.attributes) {
                            Object.keys(directive.attributes).forEach(function (name) { return attrs_1.push({ name: name }); });
                        }
                    }
                }
            }
        }
        else {
            var elementSelector = element ?
                createElementCssSelector(element) :
                createElementCssSelector(new compiler_1.Element(elementName, [], [], null, null, null));
            var matcher = new compiler_1.SelectorMatcher();
            matcher.addSelectables(selectors);
            matcher.match(elementSelector, function (selector) {
                var directive = selectorMap.get(selector);
                if (directive) {
                    var _a = getDirectiveInOuts(directive), inputs = _a.inputs, outputs = _a.outputs;
                    inputs.forEach(function (name) { return attrs_1.push({ name: name, input: true }); });
                    outputs.forEach(function (name) { return attrs_1.push({ name: name, output: true }); });
                    if (directive.attributes) {
                        Object.keys(directive.attributes).forEach(function (name) { return attrs_1.push({ name: name }); });
                    }
                }
            });
        }
        // If a name shows up twice, fold it into a single value.
        attrs_1 = foldAttrs(attrs_1);
        // Now expand them back out to ensure that input/output shows up as well as input and
        // output.
        attributes.push.apply(attributes, utils_1.flatten(attrs_1.map(expandedAttr)));
    }
    return attributes;
    //cache directive inputs and outputs
    function getDirectiveInOuts(directive) {
        var res = dir2InOuts.get(directive);
        if (!res) {
            var inputs_1 = new Set();
            var outputs_1 = new Set();
            Object.keys(directive.inputs).forEach(function (key) { return inputs_1.add(directive.inputs[key]); });
            Object.keys(directive.outputs).forEach(function (key) { return outputs_1.add(directive.outputs[key].replace(/Change$/, "")); });
            res = { inputs: inputs_1, outputs: outputs_1 };
            dir2InOuts.set(directive, res);
        }
        return res;
    }
}
exports.getAttributeInfosForElement = getAttributeInfosForElement;
function calcMostSpecificForAttrValueExpr(path, attr) {
    var mostSpecific = path.pop();
    while (mostSpecific
        && (!(mostSpecific instanceof compiler_1.BoundDirectivePropertyAst
            || mostSpecific instanceof compiler_1.BoundElementPropertyAst
            || mostSpecific instanceof compiler_1.BoundEventAst
            || mostSpecific instanceof compiler_1.BoundTextAst)
            || !sameSpan(attr.sourceSpan, mostSpecific.sourceSpan))) {
        if (mostSpecific instanceof compiler_1.AttrAst) {
            //simple attribute without any bindings, just return
            return;
        }
        if (mostSpecific instanceof compiler_1.ElementAst) {
            //*ngFor/If/etc.
            break;
        }
        mostSpecific = path.pop();
    }
    return mostSpecific;
}
function attributeValueCompletions(info, position, attr) {
    var path = utils_1.findTemplateAstAt(info.templateAst, position);
    var mostSpecific = calcMostSpecificForAttrValueExpr(path, attr);
    var dinfo = utils_1.diagnosticInfoFromTemplateInfo(info);
    if (mostSpecific) {
        var visitor = new ExpressionVisitor(info, position, attr, function () { return compiler_cli_1.getExpressionScope(dinfo, path, false); });
        mostSpecific.visit(visitor, null);
        if (!visitor.result || !visitor.result.length) {
            // Try allwoing widening the path
            var widerPath_1 = utils_1.findTemplateAstAt(info.templateAst, position, /* allowWidening */ true);
            if (widerPath_1.tail) {
                var widerVisitor = new ExpressionVisitor(info, position, attr, function () { return compiler_cli_1.getExpressionScope(dinfo, widerPath_1, false); });
                widerPath_1.tail.visit(widerVisitor, null);
                return widerVisitor.result;
            }
        }
        return visitor.result;
    }
}
function attributeValueDocumentation(info, position, attr, name, type) {
    var path = utils_1.findTemplateAstAt(info.templateAst, position);
    var mostSpecific = calcMostSpecificForAttrValueExpr(path, attr);
    if (mostSpecific) {
        var dinfo_2 = utils_1.diagnosticInfoFromTemplateInfo(info);
        var visitor = new ExpressionDocVisitor(info, position, name, type, attr, function () { return compiler_cli_1.getExpressionScope(dinfo_2, path, false); });
        mostSpecific.visit(visitor, null);
        if (!visitor.result || !visitor.result.length) {
            // Try allwoing widening the path
            var widerPath_2 = utils_1.findTemplateAstAt(info.templateAst, position, /* allowWidening */ true);
            if (widerPath_2.tail) {
                var widerVisitor = new ExpressionDocVisitor(info, position, name, type, attr, function () { return compiler_cli_1.getExpressionScope(dinfo_2, widerPath_2, false); });
                widerPath_2.tail.visit(widerVisitor, null);
                return widerVisitor.docResult;
            }
        }
        return visitor.docResult;
    }
}
function sameSpan(span1, span2) {
    return span1 && span2
        && span1.start && span1.end
        && span2.start && span2.end
        && span1.start.offset == span2.start.offset
        && span1.start.offset == span2.start.offset;
}
function elementCompletions(info, path) {
    var htmlNames = html_info_1.elementNames().filter(function (name) { return !(name in hiddenHtmlElements); });
    // Collect the elements referenced by the selectors
    var directiveElements = utils_1.getSelectors(info)
        .selectors.map(function (selector) { return selector.element; })
        .filter(function (name) { return !!name; });
    var components = directiveElements.map(function (name) { return ({ kind: 'component', name: name, sort: name }); });
    var htmlElements = htmlNames.map(function (name) { return ({ kind: 'element', name: name, sort: name }); });
    // Return components and html elements
    return utils_1.uniqueByName(htmlElements.concat(components));
}
function entityCompletions(value, position) {
    // Look for entity completions
    var re = /&[A-Za-z]*;?(?!\d)/g;
    var found;
    var result = undefined;
    while (found = re.exec(value)) {
        var len = found[0].length;
        if (position >= found.index && position < (found.index + len)) {
            result = Object.keys(compiler_1.NAMED_ENTITIES)
                .map(function (name) { return ({ kind: 'entity', name: "&" + name + ";", sort: name }); });
            break;
        }
    }
    return result;
}
function interpolationCompletions(info, position) {
    // Look for an interpolation in at the position.
    var templatePath = utils_1.findTemplateAstAt(info.templateAst, position);
    var mostSpecific = templatePath.tail;
    if (mostSpecific) {
        var visitor = new ExpressionVisitor(info, position, undefined, function () { return compiler_cli_1.getExpressionScope(utils_1.diagnosticInfoFromTemplateInfo(info), templatePath, false); });
        mostSpecific.visit(visitor, null);
        return utils_1.uniqueByName(visitor.result);
    }
}
// There is a special case of HTML where text that contains a unclosed tag is treated as
// text. For exaple '<h1> Some <a text </h1>' produces a text nodes inside of the H1
// element "Some <a text". We, however, want to treat this as if the user was requesting
// the attributes of an "a" element, not requesting completion in the a text element. This
// code checks for this case and returns element completions if it is detected or undefined
// if it is not.
function voidElementAttributeCompletions(info, path) {
    var tail = path.tail;
    if (tail instanceof compiler_1.Text) {
        var match = tail.value.match(/<(\w(\w|\d|-)*:)?(\w(\w|\d|-)*)\s/);
        // The position must be after the match, otherwise we are still in a place where elements
        // are expected (such as `<|a` or `<a|`; we only want attributes for `<a |` or after).
        if (match &&
            path.position >= (match.index || 0) + match[0].length + tail.sourceSpan.start.offset) {
            return attributeCompletionsForElement(info, match[3]);
        }
    }
}
var ExpressionVisitor = (function (_super) {
    __extends(ExpressionVisitor, _super);
    function ExpressionVisitor(info, position, attr, getExpressionScope) {
        var _this = _super.call(this) || this;
        _this.info = info;
        _this.position = position;
        _this.attr = attr;
        _this.getExpressionScope = getExpressionScope || (function () { return info.template.members; });
        return _this;
    }
    ExpressionVisitor.prototype.visitDirectiveProperty = function (ast) {
        this.attributeValueCompletions(ast.value);
    };
    ExpressionVisitor.prototype.visitElementProperty = function (ast) {
        this.attributeValueCompletions(ast.value);
    };
    ExpressionVisitor.prototype.visitEvent = function (ast) { this.attributeValueCompletions(ast.handler); };
    ExpressionVisitor.prototype.visitElement = function (ast) {
        var _this = this;
        if (this.attr && utils_1.getSelectors(this.info) && this.attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {
            // The value is a template expression but the expression AST was not produced when the
            // TemplateAst was produce so
            // do that now.
            var key_1 = this.attr.name.substr(TEMPLATE_ATTR_PREFIX.length);
            // Find the selector
            var selectorInfo = utils_1.getSelectors(this.info);
            var selectors = selectorInfo.selectors;
            var selector_1 = selectors.filter(function (s) { return s.attrs.some(function (attr, i) { return i % 2 == 0 && attr == key_1; }); })[0];
            var templateBindingResult = this.info.expressionParser.parseTemplateBindings(key_1, this.attr.value, null);
            // find the template binding that contains the position
            if (!this.attr.valueSpan)
                return;
            var valueRelativePosition_1 = this.position - this.attr.valueSpan.start.offset - 1;
            var bindings = templateBindingResult.templateBindings;
            var binding = bindings.find(function (binding) { return utils_1.inSpan(valueRelativePosition_1, binding.span, /* exclusive */ true); }) ||
                bindings.find(function (binding) { return utils_1.inSpan(valueRelativePosition_1, binding.span); });
            var keyCompletions = function () {
                var keys = [];
                if (selector_1) {
                    var attrNames = selector_1.attrs.filter(function (_, i) { return i % 2 == 0; });
                    keys = attrNames.filter(function (name) { return name.startsWith(key_1) && name != key_1; })
                        .map(function (name) { return lowerName(name.substr(key_1.length)); });
                }
                keys.push('let');
                _this.result = keys.map(function (key) { return ({ kind: 'key', name: key, sort: key }); });
            };
            if (!binding || (binding.key == key_1 && !binding.expression)) {
                // We are in the root binding. We should return `let` and keys that are left in the
                // selector.
                keyCompletions();
            }
            else if (binding.keyIsVar) {
                var equalLocation = this.attr.value.indexOf('=');
                this.result = [];
                if (equalLocation >= 0 && valueRelativePosition_1 >= equalLocation) {
                    // We are after the '=' in a let clause. The valid values here are the members of the
                    // template reference's type parameter.
                    var directiveMetadata = selectorInfo.map.get(selector_1);
                    if (directiveMetadata) {
                        var contextTable = this.info.template.query.getTemplateContext(directiveMetadata.type.reference);
                        if (contextTable) {
                            this.result = this.symbolsToCompletions(contextTable.values());
                        }
                    }
                }
                else if (binding.key && valueRelativePosition_1 <= (binding.key.length - key_1.length)) {
                    keyCompletions();
                }
            }
            else {
                // If the position is in the expression or after the key or there is no key, return the
                // expression completions
                if ((binding.expression && utils_1.inSpan(valueRelativePosition_1, binding.expression.ast.span)) ||
                    (binding.key &&
                        valueRelativePosition_1 > binding.span.start + (binding.key.length - key_1.length)) ||
                    !binding.key) {
                    var span = new compiler_1.ParseSpan(0, this.attr.value.length);
                    this.attributeValueCompletions(binding.expression ? binding.expression.ast :
                        new compiler_1.PropertyRead(span, new compiler_1.ImplicitReceiver(span), ''), valueRelativePosition_1);
                }
                else {
                    keyCompletions();
                }
            }
        }
    };
    ExpressionVisitor.prototype.visitBoundText = function (ast) {
        var expressionPosition = this.position - ast.sourceSpan.start.offset;
        if (utils_1.inSpan(expressionPosition, ast.value.span)) {
            var completions = expressions_1.getExpressionCompletions(this.getExpressionScope(), ast.value, expressionPosition, this.info.template.query);
            if (completions) {
                this.result = this.symbolsToCompletions(completions);
            }
        }
    };
    ExpressionVisitor.prototype.attributeValueCompletions = function (value, position) {
        var symbols = expressions_1.getExpressionCompletions(this.getExpressionScope(), value, position == null ? this.attributeValuePosition : position, this.info.template.query);
        if (symbols) {
            this.result = this.symbolsToCompletions(symbols);
        }
    };
    ExpressionVisitor.prototype.symbolsToCompletions = function (symbols) {
        return symbols.filter(function (s) { return !s.name.startsWith('__') && s.public; })
            .map(function (symbol) { return ({ kind: symbol.kind, name: symbol.name, sort: symbol.name }); });
    };
    Object.defineProperty(ExpressionVisitor.prototype, "attributeValuePosition", {
        get: function () {
            if (this.attr && this.attr.valueSpan) {
                return this.position - this.attr.valueSpan.start.offset - 1;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    return ExpressionVisitor;
}(compiler_1.NullTemplateVisitor));
var ExpressionDocVisitor = (function (_super) {
    __extends(ExpressionDocVisitor, _super);
    function ExpressionDocVisitor(info, position, name, kind, attr, getExpressionScope) {
        var _this = _super.call(this, info, position, attr, getExpressionScope) || this;
        _this.name = name;
        _this.kind = kind;
        return _this;
    }
    ExpressionDocVisitor.prototype.symbolsToCompletions = function (symbols) {
        var _this = this;
        var res = symbols.find(function (s) { return s.name === _this.name && s.kind === _this.kind; });
        if (res) {
            this.docResult = res.documentation;
        }
        return null;
    };
    return ExpressionDocVisitor;
}(ExpressionVisitor));
function getSourceText(template, span) {
    return template.source.substring(span.start, span.end);
}
function nameOfAttr(attr) {
    var name = attr.name;
    if (attr.output) {
        name = utils_1.removeSuffix(name, 'Events');
        name = utils_1.removeSuffix(name, 'Changed');
    }
    var result = [name];
    if (attr.output) {
        result.unshift('(');
        result.push(')');
    }
    if (attr.input) {
        result.unshift('[');
        result.push(']');
    }
    if (attr.template) {
        result.unshift('*');
    }
    if (!attr.input && !attr.output && !attr.fromHtml && !attr.template) {
        result.unshift('%');
    }
    return result.join('');
}
var templateAttr = /^(\w+:)?(template$|^\*)/;
function createElementCssSelector(element) {
    var cssSelector = new compiler_1.CssSelector();
    var elNameNoNs = compiler_1.splitNsName(element.name)[1];
    cssSelector.setElement(elNameNoNs);
    for (var _i = 0, _a = element.attrs; _i < _a.length; _i++) {
        var attr = _a[_i];
        if (!attr.name.match(templateAttr)) {
            var _b = compiler_1.splitNsName(attr.name), _ = _b[0], attrNameNoNs = _b[1];
            cssSelector.addAttribute(attrNameNoNs, attr.value);
            if (attr.name.toLowerCase() == 'class') {
                var classes = attr.value.split(/s+/g);
                classes.forEach(function (className) { return cssSelector.addClassName(className); });
            }
        }
    }
    return cssSelector;
}
function foldAttrs(attrs) {
    var inputOutput = new Map();
    var templates = new Map();
    var result = [];
    attrs.forEach(function (attr) {
        if (attr.fromHtml) {
            return attr;
        }
        if (attr.template) {
            var duplicate_1 = templates.get(attr.name);
            if (!duplicate_1) {
                result.push({ name: attr.name, template: true });
                templates.set(attr.name, attr);
            }
        }
        var duplicate = inputOutput.get(attr.name);
        if (duplicate) {
            duplicate.input = duplicate.input || attr.input;
            duplicate.output = duplicate.output || attr.output;
        }
        else {
            var cloneAttr = { name: attr.name };
            if (attr.input)
                cloneAttr.input = true;
            if (attr.output)
                cloneAttr.output = true;
            result.push(cloneAttr);
            inputOutput.set(attr.name, cloneAttr);
        }
    });
    return result;
}
function expandedAttr(attr) {
    if (attr.input && attr.output) {
        return [
            attr,
            { name: attr.name, input: true, output: false },
            { name: attr.name, input: false, output: true },
            { name: attr.name, input: false, output: false }
        ];
    }
    else if (attr.input) {
        return [
            attr,
            { name: attr.name, input: false, output: false }
        ];
    }
    return [attr];
}
function lowerName(name) {
    return name && (name[0].toLowerCase() + name.substr(1));
}
//# sourceMappingURL=completions.js.map