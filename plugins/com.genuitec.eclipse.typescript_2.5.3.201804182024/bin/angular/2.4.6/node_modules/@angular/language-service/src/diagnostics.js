/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var compiler_1 = require('@angular/compiler');
var ast_1 = require('@angular/compiler/src/ml_parser/ast');
var template_ast_1 = require('@angular/compiler/src/template_parser/template_ast');
var completions_1 = require('./completions');
var expressions_1 = require('./expressions');
var extras_1 = require('./extras');
var html_info_1 = require('./html_info');
var html_path_1 = require('./html_path');
var template_path_1 = require('./template_path');
var types_1 = require('./types');
var utils_1 = require('./utils');
function getTemplateDiagnostics(fileName, astProvider, templates, results) {
    var _loop_1 = function(template) {
        var templateResults = results.get(template.fileName);
        if (!templateResults) {
            templateResults = [];
            results.set(template.fileName, templateResults);
        }
        var ast = astProvider.getTemplateAst(template, fileName);
        if (ast) {
            var errors_1 = false;
            if (ast.parseErrors && ast.parseErrors.length) {
                templateResults.push.apply(templateResults, extras_1.processAstErrors(ast.parseErrors).map(function (e) {
                    errors_1 = errors_1 || e.level === compiler_1.ParseErrorLevel.FATAL;
                    return ({
                        kind: e.level === compiler_1.ParseErrorLevel.FATAL ? types_1.DiagnosticKind.Error : types_1.DiagnosticKind.Warning,
                        span: utils_1.offsetSpan(utils_1.spanOf(e.span), template.span.start),
                        message: e.msg
                    });
                }));
            }
            if (!errors_1 && ast.templateAst) {
                var expressionDiagnostics = getTemplateExpressionDiagnostics(template, ast);
                templateResults.push.apply(templateResults, expressionDiagnostics);
            }
            if (ast.errors) {
                templateResults.push.apply(templateResults, ast.errors.map(function (e) { return ({ kind: e.kind, span: e.span || template.span, message: e.message }); }));
            }
        }
    };
    for (var _i = 0, templates_1 = templates; _i < templates_1.length; _i++) {
        var template = templates_1[_i];
        _loop_1(template);
    }
}
exports.getTemplateDiagnostics = getTemplateDiagnostics;
function getDeclarationDiagnostics(declarations, modules) {
    var results = [];
    var directives = undefined;
    var _loop_2 = function(declaration) {
        var report = function (message, kind, span) {
            results.push({
                kind: kind || types_1.DiagnosticKind.Error,
                span: span || declaration.declarationSpan, message: message
            });
        };
        for (var _i = 0, _a = declaration.errors; _i < _a.length; _i++) {
            var error = _a[_i];
            report(error.message, types_1.DiagnosticKind.Error, error.span);
        }
        if (declaration.metadata) {
            if (declaration.metadata.isComponent) {
                if (!modules.ngModuleByPipeOrDirective.has(declaration.type)) {
                    report("Component '" + declaration.type.name + "' is not included in a module and will not be available inside a template. Consider adding it to a NgModule declaration", types_1.DiagnosticKind.Warning);
                }
            }
            else {
                if (!directives) {
                    directives = new Set();
                    modules.ngModules.forEach(function (module) {
                        module.declaredDirectives.forEach(function (directive) { directives.add(directive.reference); });
                    });
                }
                if (!directives.has(declaration.type)) {
                    report("Directive '" + declaration.type.name + "' is not included in a module and will not be available inside a template. Consider adding it to a NgModule declaration", types_1.DiagnosticKind.Warning);
                }
            }
        }
    };
    for (var _b = 0, declarations_1 = declarations; _b < declarations_1.length; _b++) {
        var declaration = declarations_1[_b];
        _loop_2(declaration);
    }
    return results;
}
exports.getDeclarationDiagnostics = getDeclarationDiagnostics;
function getTemplateExpressionDiagnostics(template, astResult) {
    var info = {
        template: template,
        htmlAst: astResult.htmlAst,
        directive: astResult.directive,
        directives: astResult.directives,
        pipes: astResult.pipes,
        templateAst: astResult.templateAst,
        expressionParser: astResult.expressionParser
    };
    var visitor = new ExpressionDiagnosticsVisitor(info, function (path, includeEvent) {
        return expressions_1.getExpressionScope(info, path, includeEvent);
    }, function (elementName, element) {
        return completions_1.getAttributeInfosForElement(info, elementName, element);
    });
    template_ast_1.templateVisitAll(visitor, astResult.templateAst);
    return visitor.diagnostics;
}
var ExpressionDiagnosticsVisitor = (function (_super) {
    __extends(ExpressionDiagnosticsVisitor, _super);
    function ExpressionDiagnosticsVisitor(info, getExpressionScope, getAttributeInfosForElement) {
        _super.call(this);
        this.info = info;
        this.getExpressionScope = getExpressionScope;
        this.getAttributeInfosForElement = getAttributeInfosForElement;
        this.diagnostics = [];
        this.path = new template_path_1.TemplateAstPath([], 0);
    }
    ExpressionDiagnosticsVisitor.prototype.visitDirective = function (ast, context) {
        // Override the default child visitor to ignore the host properties of a directive.
        if (ast.inputs && ast.inputs.length) {
            template_ast_1.templateVisitAll(this, ast.inputs, context);
        }
    };
    ExpressionDiagnosticsVisitor.prototype.visitBoundText = function (ast) {
        this.push(ast);
        this.diagnoseExpression(ast.value, ast.sourceSpan.start.offset, false);
        this.pop();
    };
    ExpressionDiagnosticsVisitor.prototype.visitDirectiveProperty = function (ast) {
        this.push(ast);
        //TODO properly resolve scope for validation of generated expressions
        if (ast.sourceSpan.details === null) {
            this.diagnoseExpression(ast.value, this.attributeValueLocation(ast), false);
        }
        this.pop();
    };
    ExpressionDiagnosticsVisitor.prototype.visitElementProperty = function (ast) {
        this.push(ast);
        //TODO properly resolve scope for validation of generated expressions
        if (ast.sourceSpan.details === null) {
            this.diagnoseExpression(ast.value, this.attributeValueLocation(ast), false);
        }
        this.pop();
    };
    ExpressionDiagnosticsVisitor.prototype.visitEvent = function (ast) {
        this.push(ast);
        //TODO properly resolve scope for validation of generated expressions
        if (ast.sourceSpan.details === null) {
            this.diagnoseExpression(ast.handler, this.attributeValueLocation(ast), true);
        }
        this.pop();
    };
    ExpressionDiagnosticsVisitor.prototype.visitVariable = function (ast) {
        var directive = this.directiveSummary;
        if (directive && ast.value) {
            var context = this.info.template.query.getTemplateContext(directive.type.reference);
            if (!context.has(ast.value)) {
                if (ast.value === '$implicit') {
                    this.reportError('The template context does not have an implicit value', utils_1.spanOf(ast.sourceSpan));
                }
                else {
                    this.reportError("The template context does not defined a member called '" + ast.value + "'", utils_1.spanOf(ast.sourceSpan));
                }
            }
        }
    };
    ExpressionDiagnosticsVisitor.prototype.visitElement = function (ast, context) {
        this.push(ast);
        _super.prototype.visitElement.call(this, ast, context);
        this.pop();
    };
    ExpressionDiagnosticsVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {
        var previousDirectiveSummary = this.directiveSummary;
        this.push(ast);
        // Find directive that refernces this template
        this.directiveSummary =
            ast.directives.map(function (d) { return d.directive; }).find(function (d) { return utils_1.hasTemplateReference(d.type); });
        // Process children
        _super.prototype.visitEmbeddedTemplate.call(this, ast, context);
        this.pop();
        this.directiveSummary = previousDirectiveSummary;
    };
    ExpressionDiagnosticsVisitor.prototype.visitAttr = function (ast) {
        var element = this.path.tail;
        var attrName = ast.name;
        if (!(element instanceof template_ast_1.ElementAst) || !element.name
            || attrName === "class" || attrName === "style") {
            return;
        }
        var msg = html_info_1.validateAttribute(attrName);
        if (msg) {
            this.reportError(msg, { start: ast.sourceSpan.start.offset, end: ast.sourceSpan.start.offset + attrName.length });
            return;
        }
        var infos = this.getAttributeInfosForElement(element.name, element);
        var caseNotMatch = false;
        var found = infos.find(function (info) { return info.name === attrName
            || info.name.toLowerCase() === attrName.toLowerCase(); });
        if (!found || (!found.input && !found.fromHtml)) {
            this.reportWarning("Unknown attribute '" + attrName + "'.", { start: ast.sourceSpan.start.offset, end: ast.sourceSpan.start.offset + attrName.length });
        }
    };
    ExpressionDiagnosticsVisitor.prototype.attributeValueLocation = function (ast) {
        var path = new html_path_1.HtmlAstPath(this.info.htmlAst, ast.sourceSpan.start.offset);
        var last = path.tail;
        if (last instanceof ast_1.Attribute && last.valueSpan) {
            // Add 1 for the quote.
            return last.valueSpan.start.offset + 1;
        }
        return ast.sourceSpan.start.offset;
    };
    ExpressionDiagnosticsVisitor.prototype.diagnoseExpression = function (ast, offset, includeEvent) {
        var _this = this;
        var scope = this.getExpressionScope(this.path, includeEvent);
        (_a = this.diagnostics).push.apply(_a, expressions_1.getExpressionDiagnostics(scope, ast, this.info.template.query)
            .map(function (d) { return ({
            span: utils_1.offsetSpan(d.ast.span, offset + _this.info.template.span.start),
            kind: d.kind,
            message: d.message,
            fileName: _this.info.template.fileName
        }); }));
        var _a;
    };
    ExpressionDiagnosticsVisitor.prototype.push = function (ast) { this.path.push(ast); };
    ExpressionDiagnosticsVisitor.prototype.pop = function () { this.path.pop(); };
    ExpressionDiagnosticsVisitor.prototype.selectors = function () {
        var result = this._selectors;
        if (!result) {
            this._selectors = result = utils_1.getSelectors(this.info);
        }
        return result;
    };
    ExpressionDiagnosticsVisitor.prototype.findElement = function (position) {
        var htmlPath = new html_path_1.HtmlAstPath(this.info.htmlAst, position);
        if (htmlPath.tail instanceof ast_1.Element) {
            return htmlPath.tail;
        }
    };
    ExpressionDiagnosticsVisitor.prototype.reportError = function (message, span) {
        this.diagnostics.push({
            span: utils_1.offsetSpan(span, this.info.template.span.start),
            kind: types_1.DiagnosticKind.Error, message: message
        });
    };
    ExpressionDiagnosticsVisitor.prototype.reportWarning = function (message, span) {
        this.diagnostics.push({
            span: utils_1.offsetSpan(span, this.info.template.span.start),
            kind: types_1.DiagnosticKind.Warning, message: message
        });
    };
    return ExpressionDiagnosticsVisitor;
}(template_path_1.TemplateAstChildVisitor));
//# sourceMappingURL=diagnostics.js.map