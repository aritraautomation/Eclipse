/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ast_1 = require('@angular/compiler/src/expression_parser/ast');
var ast_2 = require('@angular/compiler/src/ml_parser/ast');
var html_tags_1 = require('@angular/compiler/src/ml_parser/html_tags');
var tags_1 = require('@angular/compiler/src/ml_parser/tags');
var selector_1 = require('@angular/compiler/src/selector');
var template_ast_1 = require('@angular/compiler/src/template_parser/template_ast');
var expressions_1 = require('./expressions');
var html_info_1 = require('./html_info');
var html_path_1 = require('./html_path');
var template_path_1 = require('./template_path');
var utils_1 = require('./utils');
var TEMPLATE_ATTR_PREFIX = '*';
var hiddenHtmlElements = {
    html: true,
    script: true,
    noscript: true,
    base: true,
    body: true,
    title: true,
    head: true,
    link: true,
};
function getTemplateCompletions(templateInfo) {
    var result = undefined;
    var htmlAst = templateInfo.htmlAst, templateAst = templateInfo.templateAst, template = templateInfo.template;
    // The templateNode starts at the delimiter character so we add 1 to skip it.
    var templatePosition = templateInfo.position - template.span.start;
    var path = new html_path_1.HtmlAstPath(htmlAst, templatePosition);
    var mostSpecific = path.tail;
    if (path.empty) {
        result = elementCompletions(templateInfo, path);
    }
    else {
        var astPosition_1 = templatePosition - mostSpecific.sourceSpan.start.offset;
        mostSpecific.visit({
            visitElement: function (ast) {
                var startTagSpan = utils_1.spanOf(ast.sourceSpan);
                var tagLen = ast.name.length;
                if (templatePosition <=
                    startTagSpan.start + tagLen + 1 /* 1 for the opening angle bracked */) {
                    // If we are in the tag then return the element completions.
                    result = elementCompletions(templateInfo, path);
                }
                else if (templatePosition < startTagSpan.end) {
                    // We are in the attribute section of the element (but not in an attribute).
                    // Return the attribute completions.
                    result = attributeCompletions(templateInfo, path);
                }
            },
            visitAttribute: function (ast) {
                if (!ast.valueSpan || !utils_1.inSpan(templatePosition, utils_1.spanOf(ast.valueSpan))) {
                    // We are in the name of an attribute. Show attribute completions.
                    result = attributeCompletions(templateInfo, path);
                }
                else if (ast.valueSpan && utils_1.inSpan(templatePosition, utils_1.spanOf(ast.valueSpan))) {
                    result = attributeValueCompletions(templateInfo, templatePosition, ast);
                }
            },
            visitText: function (ast) {
                // Check if we are in a entity.
                result = entityCompletions(getSourceText(template, utils_1.spanOf(ast)), astPosition_1);
                if (result)
                    return result;
                result = interpolationCompletions(templateInfo, templatePosition);
                if (result)
                    return result;
                var element = path.first(ast_2.Element);
                if (element) {
                    var definition = html_tags_1.getHtmlTagDefinition(element.name);
                    if (definition.contentType === tags_1.TagContentType.PARSABLE_DATA) {
                        result = voidElementAttributeCompletions(templateInfo, path);
                        if (!result) {
                            // If the element can hold content Show element completions.
                            result = elementCompletions(templateInfo, path);
                        }
                    }
                }
                else {
                    // If no element container, implies parsable data so show elements.
                    result = voidElementAttributeCompletions(templateInfo, path);
                    if (!result) {
                        result = elementCompletions(templateInfo, path);
                    }
                }
            },
            visitComment: function (ast) { },
            visitExpansion: function (ast) { },
            visitExpansionCase: function (ast) { }
        }, null);
    }
    return result;
}
exports.getTemplateCompletions = getTemplateCompletions;
function attributeCompletions(info, path) {
    var item = path.tail instanceof ast_2.Element ? path.tail : path.parentOf(path.tail);
    if (item instanceof ast_2.Element) {
        return attributeCompletionsForElement(info, item.name, item);
    }
    return undefined;
}
function attributeCompletionsForElement(info, elementName, element) {
    var attributes = getAttributeInfosForElement(info, elementName, element);
    // Map all the attributes to a completion
    return attributes.map(function (attr) { return ({
        kind: attr.fromHtml
            ? ((attr.input || attr.output) ? 'html property' : 'html attribute')
            : 'directive property',
        name: nameOfAttr(attr),
        sort: attr.name
    }); });
}
function getAttributeInfosForElement(info, elementName, element) {
    var attributes = [];
    // Add html attributes
    var htmlAttributes = html_info_1.attributeNames(elementName) || [];
    if (htmlAttributes) {
        attributes.push.apply(attributes, htmlAttributes.map(function (name) { return ({ name: name, fromHtml: true }); }));
    }
    // Add DOM properties
    var htmlProperties = html_info_1.propertyNames(elementName);
    if (htmlProperties) {
        attributes.push.apply(attributes, htmlProperties.map(function (name) { return ({ name: name, fromHtml: true, input: true }); }));
    }
    // Add DOM events
    var htmlEvents = html_info_1.eventNames(elementName);
    if (htmlEvents) {
        attributes.push.apply(attributes, htmlEvents.map(function (name) { return ({ name: name, fromHtml: true, output: true }); }));
    }
    var _a = utils_1.getSelectors(info), selectors = _a.selectors, selectorMap = _a.map;
    var dir2InOuts = new Map();
    if (selectors && selectors.length) {
        // All the attributes that are selectable should be shown.
        var applicableSelectors = selectors.filter(function (selector) { return !selector.element || selector.element == elementName; });
        var selectorAndAttributeNames = applicableSelectors.map(function (selector) { return ({ selector: selector, attrs: selector.attrs.filter(function (a) { return !!a; }) }); });
        // Add all self-selectable attributes
        var attrs_1 = utils_1.flatten(selectorAndAttributeNames.map(function (selectorAndAttr) {
            var directive = selectorMap.get(selectorAndAttr.selector);
            var _a = getDirectiveInOuts(directive), inputs = _a.inputs, outputs = _a.outputs;
            var result = selectorAndAttr.attrs.map(function (name) { return ({ name: name, input: inputs.has(name), output: outputs.has(name) }); });
            return result;
        }));
        // Add template attribute if a directive contains a template reference
        selectorAndAttributeNames.forEach(function (selectorAndAttr) {
            var selector = selectorAndAttr.selector;
            var directive = selectorMap.get(selector);
            if (directive && utils_1.hasTemplateReference(directive.type) && selector.attrs.length &&
                selector.attrs[0]) {
                attrs_1.push({ name: selector.attrs[0], template: true });
            }
        });
        // All input and output properties of the matching directives should be added.
        var elementSelector = element ?
            createElementCssSelector(element) :
            createElementCssSelector(new ast_2.Element(elementName, [], [], undefined, undefined, undefined));
        var matcher = new selector_1.SelectorMatcher();
        matcher.addSelectables(selectors);
        matcher.match(elementSelector, function (selector) {
            var directive = selectorMap.get(selector);
            if (directive) {
                var _a = getDirectiveInOuts(directive), inputs = _a.inputs, outputs = _a.outputs;
                inputs.forEach(function (name) { return attrs_1.push({ name: name, input: true }); });
                outputs.forEach(function (name) { return attrs_1.push({ name: name, output: true }); });
            }
        });
        // If a name shows up twice, fold it into a single value.
        attrs_1 = foldAttrs(attrs_1);
        // Now expand them back out to ensure that input/output shows up as well as input and
        // output.
        attributes.push.apply(attributes, utils_1.flatten(attrs_1.map(expandedAttr)));
    }
    return attributes;
    //cache directive inputs and outputs
    function getDirectiveInOuts(directive) {
        var res = dir2InOuts.get(directive);
        if (!res) {
            var inputs_1 = new Set();
            var outputs_1 = new Set();
            Object.keys(directive.inputs).forEach(function (key) { return inputs_1.add(directive.inputs[key]); });
            Object.keys(directive.outputs).forEach(function (key) { return outputs_1.add(directive.outputs[key].replace(/Change$/, "")); });
            res = { inputs: inputs_1, outputs: outputs_1 };
            dir2InOuts.set(directive, res);
        }
        return res;
    }
}
exports.getAttributeInfosForElement = getAttributeInfosForElement;
function attributeValueCompletions(info, position, attr) {
    var path = new template_path_1.TemplateAstPath(info.templateAst, position);
    var mostSpecific = path.pop();
    while (mostSpecific
        && (!(mostSpecific instanceof template_ast_1.BoundDirectivePropertyAst
            || mostSpecific instanceof template_ast_1.BoundElementPropertyAst
            || mostSpecific instanceof template_ast_1.BoundEventAst
            || mostSpecific instanceof template_ast_1.BoundTextAst)
            || !sameSpan(attr.sourceSpan, mostSpecific.sourceSpan))) {
        if (mostSpecific instanceof template_ast_1.AttrAst) {
            //simple attribute without any bindings, just return
            return;
        }
        if (mostSpecific instanceof template_ast_1.ElementAst) {
            //*ngFor/If/etc.
            break;
        }
        mostSpecific = path.pop();
    }
    if (mostSpecific) {
        var visitor = new ExpressionVisitor(info, position, attr, function () { return expressions_1.getExpressionScope(info, path, false); });
        mostSpecific.visit(visitor, null);
        if (!visitor.result || !visitor.result.length) {
            // Try allwoing widening the path
            var widerPath_1 = new template_path_1.TemplateAstPath(info.templateAst, position, /* allowWidening */ true);
            if (widerPath_1.tail) {
                var widerVisitor = new ExpressionVisitor(info, position, attr, function () { return expressions_1.getExpressionScope(info, widerPath_1, false); });
                widerPath_1.tail.visit(widerVisitor, null);
                return widerVisitor.result;
            }
        }
        return visitor.result;
    }
}
function sameSpan(span1, span2) {
    return span1 && span2
        && span1.start && span1.end
        && span2.start && span2.end
        && span1.start.offset == span2.start.offset
        && span1.start.offset == span2.start.offset;
}
function elementCompletions(info, path) {
    var htmlNames = html_info_1.elementNames().filter(function (name) { return !(name in hiddenHtmlElements); });
    // Collect the elements referenced by the selectors
    var directiveElements = utils_1.getSelectors(info).selectors.map(function (selector) { return selector.element; }).filter(function (name) { return !!name; });
    var components = directiveElements.map(function (name) { return ({ kind: 'component', name: name, sort: name }); });
    var htmlElements = htmlNames.map(function (name) { return ({ kind: 'element', name: name, sort: name }); });
    // Return components and html elements
    return utils_1.uniqueByName(htmlElements.concat(components));
}
function entityCompletions(value, position) {
    // Look for entity completions
    var re = /&[A-Za-z]*;?(?!\d)/g;
    var found;
    var result;
    while (found = re.exec(value)) {
        var len = found[0].length;
        if (position >= found.index && position < (found.index + len)) {
            result = Object.keys(tags_1.NAMED_ENTITIES)
                .map(function (name) { return ({ kind: 'entity', name: "&" + name + ";", sort: name }); });
            break;
        }
    }
    return result;
}
function interpolationCompletions(info, position) {
    // Look for an interpolation in at the position.
    var templatePath = new template_path_1.TemplateAstPath(info.templateAst, position);
    var mostSpecific = templatePath.tail;
    if (mostSpecific) {
        var visitor = new ExpressionVisitor(info, position, undefined, function () { return expressions_1.getExpressionScope(info, templatePath, false); });
        mostSpecific.visit(visitor, null);
        return utils_1.uniqueByName(visitor.result);
    }
}
// There is a special case of HTML where text that contains a unclosed tag is treated as
// text. For exaple '<h1> Some <a text </h1>' produces a text nodes inside of the H1
// element "Some <a text". We, however, want to treat this as if the user was requesting
// the attributes of an "a" element, not requesting completion in the a text element. This
// code checks for this case and returns element completions if it is detected or undefined
// if it is not.
function voidElementAttributeCompletions(info, path) {
    var tail = path.tail;
    if (tail instanceof ast_2.Text) {
        var match = tail.value.match(/<(\w(\w|\d|-)*:)?(\w(\w|\d|-)*)\s/);
        // The position must be after the match, otherwise we are still in a place where elements
        // are expected (such as `<|a` or `<a|`; we only want attributes for `<a |` or after).
        if (match && path.position >= match.index + match[0].length + tail.sourceSpan.start.offset) {
            return attributeCompletionsForElement(info, match[3]);
        }
    }
}
var ExpressionVisitor = (function (_super) {
    __extends(ExpressionVisitor, _super);
    function ExpressionVisitor(info, position, attr, getExpressionScope) {
        _super.call(this);
        this.info = info;
        this.position = position;
        this.attr = attr;
        this.getExpressionScope = getExpressionScope;
        if (!getExpressionScope) {
            this.getExpressionScope = function () { return info.template.members; };
        }
    }
    ExpressionVisitor.prototype.visitDirectiveProperty = function (ast) {
        this.attributeValueCompletions(ast.value);
    };
    ExpressionVisitor.prototype.visitElementProperty = function (ast) {
        this.attributeValueCompletions(ast.value);
    };
    ExpressionVisitor.prototype.visitEvent = function (ast) { this.attributeValueCompletions(ast.handler); };
    ExpressionVisitor.prototype.visitElement = function (ast) {
        var _this = this;
        if (this.attr && utils_1.getSelectors(this.info) && this.attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {
            // The value is a template expression but the expression AST was not produced when the
            // TemplateAst was produce so
            // do that now.
            var key_1 = this.attr.name.substr(TEMPLATE_ATTR_PREFIX.length);
            // Find the selector
            var selectorInfo = utils_1.getSelectors(this.info);
            var selectors = selectorInfo.selectors;
            var selector_2 = selectors.filter(function (s) { return s.attrs.some(function (attr, i) { return i % 2 == 0 && attr == key_1; }); })[0];
            var templateBindingResult = this.info.expressionParser.parseTemplateBindings(key_1, this.attr.value, null);
            // find the template binding that contains the position
            var valueRelativePosition_1 = this.position - this.attr.valueSpan.start.offset - 1;
            var bindings = templateBindingResult.templateBindings;
            var binding = bindings.find(function (binding) { return utils_1.inSpan(valueRelativePosition_1, binding.span, /* exclusive */ true); }) ||
                bindings.find(function (binding) { return utils_1.inSpan(valueRelativePosition_1, binding.span); });
            var keyCompletions = function () {
                var keys = [];
                if (selector_2) {
                    var attrNames = selector_2.attrs.filter(function (_, i) { return i % 2 == 0; });
                    keys = attrNames.filter(function (name) { return name.startsWith(key_1) && name != key_1; })
                        .map(function (name) { return lowerName(name.substr(key_1.length)); });
                }
                keys.push('let');
                _this.result = keys.map(function (key) { return { kind: 'key', name: key, sort: key }; });
            };
            if (!binding || (binding.key == key_1 && !binding.expression)) {
                // We are in the root binding. We should return `let` and keys that are left in the
                // selector.
                keyCompletions();
            }
            else if (binding.keyIsVar) {
                var equalLocation = this.attr.value.indexOf('=');
                this.result = [];
                if (equalLocation >= 0 && valueRelativePosition_1 >= equalLocation) {
                    // We are after the '=' in a let clause. The valid values here are the members of the
                    // template reference's type parameter.
                    var directiveMetadata = selectorInfo.map.get(selector_2);
                    var contextTable = this.info.template.query.getTemplateContext(directiveMetadata.type.reference);
                    if (contextTable) {
                        this.result = this.symbolsToCompletions(contextTable.values());
                    }
                }
                else if (binding.key && valueRelativePosition_1 <= (binding.key.length - key_1.length)) {
                    keyCompletions();
                }
            }
            else {
                // If the position is in the expression or after the key or there is no key, return the
                // expression completions
                if ((binding.expression && utils_1.inSpan(valueRelativePosition_1, binding.expression.ast.span)) ||
                    (binding.key &&
                        valueRelativePosition_1 > binding.span.start + (binding.key.length - key_1.length)) ||
                    !binding.key) {
                    var span = new ast_1.ParseSpan(0, this.attr.value.length);
                    this.attributeValueCompletions(binding.expression ? binding.expression.ast :
                        new ast_1.PropertyRead(span, new ast_1.ImplicitReceiver(span), ''), valueRelativePosition_1);
                }
                else {
                    keyCompletions();
                }
            }
        }
    };
    ExpressionVisitor.prototype.visitBoundText = function (ast) {
        var expressionPosition = this.position - ast.sourceSpan.start.offset;
        if (utils_1.inSpan(expressionPosition, ast.value.span)) {
            var completions = expressions_1.getExpressionCompletions(this.getExpressionScope(), ast.value, expressionPosition, this.info.template.query);
            if (completions) {
                this.result = this.symbolsToCompletions(completions);
            }
        }
    };
    ExpressionVisitor.prototype.attributeValueCompletions = function (value, position) {
        var symbols = expressions_1.getExpressionCompletions(this.getExpressionScope(), value, position == null ? this.attributeValuePosition : position, this.info.template.query);
        if (symbols) {
            this.result = this.symbolsToCompletions(symbols);
        }
    };
    ExpressionVisitor.prototype.symbolsToCompletions = function (symbols) {
        return symbols.filter(function (s) { return !s.name.startsWith('__') && s.public; })
            .map(function (symbol) { return { kind: symbol.kind, name: symbol.name, sort: symbol.name }; });
    };
    Object.defineProperty(ExpressionVisitor.prototype, "attributeValuePosition", {
        get: function () {
            return this.position - this.attr.valueSpan.start.offset - 1;
        },
        enumerable: true,
        configurable: true
    });
    return ExpressionVisitor;
}(template_path_1.NullTemplateVisitor));
function getSourceText(template, span) {
    return template.source.substring(span.start, span.end);
}
function nameOfAttr(attr) {
    var name = attr.name;
    if (attr.output) {
        name = utils_1.removeSuffix(name, 'Events');
        name = utils_1.removeSuffix(name, 'Changed');
    }
    var result = [name];
    if (attr.input) {
        result.unshift('[');
        result.push(']');
    }
    if (attr.output) {
        result.unshift('(');
        result.push(')');
    }
    if (attr.template) {
        result.unshift('*');
    }
    return result.join('');
}
var templateAttr = /^(\w+:)?(template$|^\*)/;
function createElementCssSelector(element) {
    var cssSelector = new selector_1.CssSelector();
    var elNameNoNs = tags_1.splitNsName(element.name)[1];
    cssSelector.setElement(elNameNoNs);
    for (var _i = 0, _a = element.attrs; _i < _a.length; _i++) {
        var attr = _a[_i];
        if (!attr.name.match(templateAttr)) {
            var _b = tags_1.splitNsName(attr.name), _ = _b[0], attrNameNoNs = _b[1];
            cssSelector.addAttribute(attrNameNoNs, attr.value);
            if (attr.name.toLowerCase() == 'class') {
                var classes = attr.value.split(/s+/g);
                classes.forEach(function (className) { return cssSelector.addClassName(className); });
            }
        }
    }
    return cssSelector;
}
function foldAttrs(attrs) {
    var inputOutput = new Map();
    var templates = new Map();
    var result = [];
    attrs.forEach(function (attr) {
        if (attr.fromHtml) {
            return attr;
        }
        if (attr.template) {
            var duplicate = templates.get(attr.name);
            if (!duplicate) {
                result.push({ name: attr.name, template: true });
                templates.set(attr.name, attr);
            }
        }
        if (attr.input || attr.output) {
            var duplicate = inputOutput.get(attr.name);
            if (duplicate) {
                duplicate.input = duplicate.input || attr.input;
                duplicate.output = duplicate.output || attr.output;
            }
            else {
                var cloneAttr = { name: attr.name };
                if (attr.input)
                    cloneAttr.input = true;
                if (attr.output)
                    cloneAttr.output = true;
                result.push(cloneAttr);
                inputOutput.set(attr.name, cloneAttr);
            }
        }
    });
    return result;
}
function expandedAttr(attr) {
    if (attr.input && attr.output) {
        return [
            attr, { name: attr.name, input: true, output: false },
            { name: attr.name, input: false, output: true }
        ];
    }
    return [attr];
}
function lowerName(name) {
    return name && (name[0].toLowerCase() + name.substr(1));
}
//# sourceMappingURL=completions.js.map