/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
"use strict";
var compiler_1 = require('@angular/compiler');
var selector_1 = require('@angular/compiler/src/selector');
var ts = require('typescript');
function isParseSourceSpan(value) {
    return value && !!value.start;
}
exports.isParseSourceSpan = isParseSourceSpan;
function spanOf(span) {
    if (!span)
        return undefined;
    if (isParseSourceSpan(span)) {
        return { start: span.start.offset, end: span.end.offset };
    }
    else {
        if (span.endSourceSpan) {
            return { start: span.sourceSpan.start.offset, end: span.endSourceSpan.end.offset };
        }
        else if (span.children && span.children.length) {
            return {
                start: span.sourceSpan.start.offset,
                end: spanOf(span.children[span.children.length - 1]).end
            };
        }
        return { start: span.sourceSpan.start.offset, end: span.sourceSpan.end.offset };
    }
}
exports.spanOf = spanOf;
function inSpan(position, span, exclusive) {
    return span && exclusive ? position >= span.start && position < span.end :
        position >= span.start && position <= span.end;
}
exports.inSpan = inSpan;
function offsetSpan(span, amount) {
    return { start: span.start + amount, end: span.end + amount };
}
exports.offsetSpan = offsetSpan;
function isNarrower(spanA, spanB) {
    return spanA.start >= spanB.start && spanA.end <= spanB.end;
}
exports.isNarrower = isNarrower;
function hasTemplateReference(type) {
    if (type.diDeps) {
        for (var _i = 0, _a = type.diDeps; _i < _a.length; _i++) {
            var diDep = _a[_i];
            if (diDep.token.identifier && compiler_1.identifierName(diDep.token.identifier) == 'TemplateRef')
                return true;
        }
    }
    return false;
}
exports.hasTemplateReference = hasTemplateReference;
function getSelectors(info) {
    var map = new Map();
    var selectors = flatten(info.directives.map(function (directive) {
        var selectors = selector_1.CssSelector.parse(directive.selector);
        selectors.forEach(function (selector) { return map.set(selector, directive); });
        return selectors;
    }));
    return { selectors: selectors, map: map };
}
exports.getSelectors = getSelectors;
function flatten(a) {
    return (_a = []).concat.apply(_a, a);
    var _a;
}
exports.flatten = flatten;
function removeSuffix(value, suffix) {
    if (value.endsWith(suffix))
        return value.substring(0, value.length - suffix.length);
    return value;
}
exports.removeSuffix = removeSuffix;
function uniqueByName(elements) {
    if (elements) {
        var result = [];
        var set = new Set();
        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
            var element = elements_1[_i];
            if (!set.has(element.name)) {
                set.add(element.name);
                result.push(element);
            }
        }
        return result;
    }
}
exports.uniqueByName = uniqueByName;
function isTypescriptVersion(low, high) {
    var version = ts.version;
    if (version.substring(0, low.length) < low)
        return false;
    if (high && (version.substring(0, high.length) > high))
        return false;
    return true;
}
exports.isTypescriptVersion = isTypescriptVersion;
//# sourceMappingURL=utils.js.map