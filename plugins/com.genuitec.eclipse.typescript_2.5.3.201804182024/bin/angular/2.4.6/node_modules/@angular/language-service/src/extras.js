"use strict";
var types_1 = require('./types');
var compiler = require('@angular/compiler');
var lang_1 = require('@angular/core/src/facade/lang');
var parse_util_1 = require('@angular/compiler/src/parse_util');
var GENERATED_FILES = /\.ngfactory\.ts$|\.css\.ts$|\.css\.shim\.ts$/;
var GENERATED_OR_DTS_FILES = /\.d\.ts$|\.ngfactory\.ts$|\.css\.ts$|\.css\.shim\.ts$/;
/*
export class ExtModuleCollector {

  constructor(
    private staticReflector: StaticReflector, private reflectorHost: StaticReflectorHost,
    private program: ts.Program, private options: AngularCompilerOptions,
    private metadataResolver: CompileMetadataResolver,
    private logger: Logger) { }

  getModuleSymbols(): { fileMetas: FileMetadata[], ngModules: StaticSymbol[] } {
    // Compare with false since the default should be true
    const skipFileNames = (this.options.generateCodeForLibraries === false) ?
      GENERATED_OR_DTS_FILES :
      GENERATED_FILES;
    let filePaths = this.program.getSourceFiles()
      .filter(sf => !skipFileNames.test(sf.fileName))
      .map(sf => this.reflectorHost.getCanonicalFileName(sf.fileName));
    const fileMetas = filePaths.map((filePath) => this.readFileMetadata(filePath));
    const ngModules = fileMetas.reduce((ngModules, fileMeta) => {
      ngModules.push(...fileMeta.ngModules);
      return ngModules;
    }, <StaticSymbol[]>[]);
    return { fileMetas, ngModules };
  }

  private readFileMetadata(absSourcePath: string): FileMetadata {
    const moduleMetadata = this.staticReflector.getModuleMetadata(absSourcePath);
    const result: FileMetadata = { components: [], ngModules: [], fileUrl: absSourcePath };
    if (!moduleMetadata) {
      console.log(`WARNING: no metadata found for ${absSourcePath}`);
      return result;
    }
    const metadata = moduleMetadata['metadata'];
    const symbols = metadata && Object.keys(metadata);
    if (!symbols || !symbols.length) {
      return result;
    }
    for (const symbol of symbols) {
      if (metadata[symbol] && metadata[symbol].__symbolic == 'error') {
        // Ignore symbols that are only included to record error information.
        continue;
      }
      try {
        const staticType = this.reflectorHost.findDeclaration(absSourcePath, symbol, absSourcePath);
        const annotations = this.staticReflector.annotations(staticType);
        annotations.forEach((annotation) => {
          if (annotation instanceof NgModule) {
            this.sanitizeNgModuleAnnotation(annotation);
            result.ngModules.push(staticType);
          } else if (annotation instanceof Component) {
            result.components.push(staticType);
          }
        });
      } catch (e) {
        this.logger.log(e);
      }
    }
    return result;
  }

  private sanitizeNgModuleAnnotation(annot: NgModule) {
    const this_ = this;

    if (annot.imports) {
      annot.imports = sanitizeArr(annot.imports, sanitizeImport);
    }

    if (annot.exports) {
      annot.exports = sanitizeArr(annot.exports, sanitizeExport);
    }

    if (annot.declarations) {
      annot.declarations = sanitizeArr(annot.declarations, sanitizeDeclarations);
    }

    if (annot.providers) {
      try {
        this_.metadataResolver.getProvidersMetadata(annot.providers, [], "");
      } catch (e) {
        annot.providers = []
      }
    }

    if (annot.entryComponents) {
      annot.entryComponents = [];
    }

    if (annot.bootstrap) {
      annot.bootstrap = []
    }

    function sanitizeArr<T>(arr: T[], sanitizeMethod: (val: any) => boolean): T[] {
      return arr.map((item) => {
        const type = resolveForwardRef(item);
        if (Array.isArray(type)) {
          return sanitizeArr(type, sanitizeMethod);
        }
        if (sanitizeMethod(type)) {
          return type;
        };
        return null
      }).filter(item => !!item);
    }

    function sanitizeImport(importedType: any): boolean {
      try {
        let importedModuleType: Type<any>;
        if (isValidType(importedType)) {
          importedModuleType = importedType;
        } else if (importedType && importedType.ngModule) {
          const moduleWithProviders: ModuleWithProviders = importedType;
          importedModuleType = moduleWithProviders.ngModule;
          if (moduleWithProviders.providers) {
            try {
              this_.metadataResolver.getProvidersMetadata(moduleWithProviders.providers, [], "");
            } catch (e) {
              moduleWithProviders.providers = []
            }
          }
        }
        if (importedModuleType) {
          //TODO: sanitize imported module
          const importedMeta = this_.metadataResolver.getNgModuleMetadata(importedModuleType, false);
          if (importedMeta != null) {
            return true;
          }
        }
      } catch (e) {
        //ignore
      }
      return false
    }

    function sanitizeExport(exportedType: any): boolean {
      return isValidType(exportedType)
        && isPresent(this_.metadataResolver.getDirectiveMetadata(exportedType, false)
          || this_.metadataResolver.getPipeMetadata(exportedType, false)
          || this_.metadataResolver.getNgModuleMetadata(exportedType, false));
    }

    function sanitizeDeclarations(declaredType: any): boolean {
      return isValidType(declaredType)
        && isPresent(this_.metadataResolver.getDirectiveMetadata(declaredType, false)
          || this_.metadataResolver.getPipeMetadata(declaredType, false));
    }
  }

}

function isValidType(value: any): boolean {
  return isStaticSymbol(value) || (value instanceof Type);
}

function isStaticSymbol(value: any): value is StaticSymbol {
  return isStrictStringMap(value) && isPresent(value['name']) && isPresent(value['filePath']);
}
*/
/*
export class ModuleNormalizer {

  private normalizer: SafeDirectiveNormalizer

  constructor(host: ts.LanguageServiceHost, private logger: Logger) {

    const resourceLoader: compiler.ResourceLoader = {
      get: (s: string) => {
        var snapshot = host.getScriptSnapshot(s);
        if (snapshot === undefined) {
          throw new Error(`Compilation failed. Resource file not found: ${s}`);
        }
        return Promise.resolve(snapshot && snapshot.getText(0, snapshot.getLength()));
      }
    }

    const htmlParser = new compiler.I18NHtmlParser(new HtmlParser(), "", null);
    const urlResolver: compiler.UrlResolver = compiler.createOfflineCompileUrlResolver();

    this.normalizer = new SafeDirectiveNormalizer(
      logger, resourceLoader, urlResolver, htmlParser,
      new compiler.CompilerConfig({
        genDebugInfo: true,
        defaultEncapsulation: ViewEncapsulation.Emulated,
        logBindingUpdate: false,
        useJit: false
      }));

  }

  public normalizeModules(modules: NgModulesSummary): Promise<NgModulesSummary> {
    var result: Promise<CompileNgModuleMetadata>[] = []

    modules.ngModules.forEach((module) => {
      try {
        result.push(this.normalizeModule(module))
      } catch (e) {
        this.logger.log(e)
      }
    })
    return Promise.all(result).then(modules => {
      const ngModuleByComponent = new Map<StaticSymbol, CompileNgModuleMetadata>();
      for (let ngModuleMeta of modules) {
        ngModuleMeta.declaredDirectives.forEach((dirMeta: CompileDirectiveMetadata) => {
          if (dirMeta.isComponent) {
            ngModuleByComponent.set(dirMeta.type.reference, ngModuleMeta);
          }
        });
      }
      return Promise.resolve(new NgModulesSummary(ngModuleByComponent, modules))
    })
  }

  private normalizeModule(module: CompileNgModuleMetadata): Promise<CompileNgModuleMetadata> {
    var result = new CompileNgModuleMetadata(module);

    var this_ = this

    function resolveDir(d: CompileDirectiveMetadata) {
      return this_.normalizer
        .normalizeDirective(d)
        .asyncResult
        .catch((e: any) => {
          this_.logger.log(e)
          return Promise.resolve(null)
        })
    }

    return Promise.all([
      //normalize declared directives
      Promise
        .all(module.declaredDirectives.map(resolveDir))
        .then(dirs => { result.declaredDirectives = dirs.filter(d => !!d) }),

      //normalize exported directives
      Promise
        .all(module.exportedDirectives.map(resolveDir))
        .then(dirs => { result.exportedDirectives = dirs.filter(d => !!d) }),

      //normalize transitive directives
      Promise
        .all(module.transitiveModule.directives.map(resolveDir))
        .then(dirs => {
          result.transitiveModule = new TransitiveCompileNgModuleMetadata(
            module.transitiveModule.modules,
            module.transitiveModule.providers,
            module.transitiveModule.entryComponents,
            dirs.filter(d => !!d),
            module.transitiveModule.pipes
          )
        })
    ]).then(() => Promise.resolve(result));

  }

}
*/
/*
class SafeDirectiveNormalizer extends DirectiveNormalizer {

  constructor(private logger: Logger, _resourceLoader: compiler.ResourceLoader, _urlResolver: compiler.UrlResolver,
    _htmlParser: HtmlParser, private config: compiler.CompilerConfig) {
    super(_resourceLoader, _urlResolver, _htmlParser, config);
  }

  normalizeLoadedTemplate(
    directiveType: compiler.CompileTypeMetadata, templateMeta: compiler.CompileTemplateMetadata, template: string,
    templateAbsUrl: string): compiler.CompileTemplateMetadata {

    try {
      return super.normalizeLoadedTemplate(directiveType, templateMeta, template, templateAbsUrl);
    } catch (e) {
      if (!(e.message && e.message.indexOf("Template parse errors") === 0)) {
        this.logger.log(e);
      }
    }

    let encapsulation = templateMeta.encapsulation;
    if (encapsulation === undefined || encapsulation === null) {
      encapsulation = this.config.defaultEncapsulation;
    }

    return new compiler.CompileTemplateMetadata({
      encapsulation,
      template,
      templateUrl: templateAbsUrl, styles: [], styleUrls: [],
      externalStylesheets: templateMeta.externalStylesheets,
      ngContentSelectors: [],
      animations: templateMeta.animations,
      interpolation: templateMeta.interpolation,
    });
  }

}
*/
function processAstErrors(errors) {
    var parseErrors = new Set();
    var unknownBindings = new Set();
    //process unknown bindings
    errors.forEach(function (error) {
        //check if it's a binding error
        var msg = error.msg;
        var bindingErrStr = "' is not a known element:\n1. If '";
        var ind;
        if ((ind = msg.indexOf(bindingErrStr)) > 0) {
            var name_1 = msg.substring(1, ind);
            //add to unknown bindings
            unknownBindings.add(name_1);
            //correct error location
            error.span.start.offset++;
            error.span.end.offset = error.span.start.offset + name_1.length;
            //show as warning
            error.level = parse_util_1.ParseErrorLevel.WARNING;
            //update error message add \t\t before 1. and 2.
            var bindingErrStr2 = "part of this module.\n2. If '";
            var ind2 = msg.indexOf(bindingErrStr2);
            if (ind2 > 0) {
                error.msg = msg.substring(0, ind)
                    + "' is not a known element:\n\t1. If '"
                    + msg.substring(ind + bindingErrStr.length, ind2)
                    + "part of this module.\n\t2. If '"
                    + msg.substring(ind2 + bindingErrStr2.length);
            }
        }
    });
    return errors.map(function (error) {
        var msg = error.msg;
        var ind;
        if (msg.indexOf("Parser Error:") === 0) {
            //Parse errors may be duplicated, filter duplicates out
            if (parseErrors.has(msg)) {
                return;
            }
            parseErrors.add(msg);
        }
        else if ((ind = msg.indexOf("Can't bind to '")) === 0) {
            //show as warning
            error.level = parse_util_1.ParseErrorLevel.WARNING;
            var str = "' since it isn't a known property of '";
            var ind2 = msg.indexOf(str);
            if (ind2 > 0) {
                var name_2 = msg.substring(ind2 + str.length, msg.length - 2);
                if (unknownBindings.has(name_2)) {
                    //if we have unknown binding do not report errors on attributes
                    return;
                }
            }
        }
        else if ((ind = msg.indexOf("There is no directive with ")) === 0) {
            //show as warning
            error.level = parse_util_1.ParseErrorLevel.WARNING;
        }
        return error;
    }).filter(function (f) { return !!f; });
}
exports.processAstErrors = processAstErrors;
var TypeScriptFileValidator = (function () {
    function TypeScriptFileValidator(source, declarations, analyzedModules, host, basePath, getDirectiveModuleUri, getTemplateClassFromStaticSymbol) {
        this.source = source;
        this.declarations = declarations;
        this.analyzedModules = analyzedModules;
        this.host = host;
        this.basePath = basePath;
        this.getDirectiveModuleUri = getDirectiveModuleUri;
        this.getTemplateClassFromStaticSymbol = getTemplateClassFromStaticSymbol;
        this.result = [];
        this.urlResolver = compiler.createOfflineCompileUrlResolver();
    }
    TypeScriptFileValidator.prototype.diagnostics = function () {
        for (var _i = 0, _a = this.declarations; _i < _a.length; _i++) {
            var decl = _a[_i];
            var decorator = findDecorator(decl.metadata, this.getTemplateClassFromStaticSymbol(decl.type));
            if (decorator) {
                //validate component duplication
                this.validateComponent(decl.metadata, decorator);
                //validate template attributes
                if (decl.metadata.isComponent) {
                    this.validateTemplateAttributes(decl.metadata, decorator);
                }
            }
        }
        return this.result;
    };
    TypeScriptFileValidator.prototype.validateComponent = function (directive, decorator) {
        //check if component is part of multiple modules
        var modules = this.analyzedModules.ngModules.filter(function (module) { return module.declaredDirectives.find(function (dir) { return dir.reference === directive.type.reference; }); });
        //presence in any module is checked through 
        if (modules.length > 1) {
            var modulesStr = ""; //${stringify(oldModule)} and ${stringify(moduleType)}
            modules.forEach(function (module, index) {
                if (index == modules.length - 1) {
                    modulesStr += " and ";
                }
                else if (index > 0) {
                    modulesStr += " ";
                }
                modulesStr += lang_1.stringify(module.type.reference);
            });
            var typeStr = lang_1.stringify(directive.type.reference);
            this.addDiagnostic(decorator, null, false, ((directive.isComponent ? "Component" : "Directive") + " " + typeStr + " is part of the declarations of modules " + modulesStr + ". ") +
                ("Please consider moving " + typeStr + " to a higher module that imports " + modulesStr + ". ") +
                ("You can also create a new NgModule that exports and includes " + typeStr + " then import that NgModule in " + modulesStr), types_1.DiagnosticKind.Warning);
        }
    };
    TypeScriptFileValidator.prototype.validateTemplateAttributes = function (directive, decorator) {
        var url;
        var template;
        var declFileName = this.getDirectiveModuleUri(directive);
        var templateProp = findProperty(decorator, "template");
        var templateUrlProp = findProperty(decorator, "templateUrl");
        if (templateProp && templateUrlProp) {
            this.addDiagnostic(decorator, "template", false, "Cannot specify both 'template' and 'templateUrl' attributes", types_1.DiagnosticKind.Error);
            this.addDiagnostic(decorator, "templateUrl", false, "Cannot specify both 'template' and 'templateUrl' attributes", types_1.DiagnosticKind.Error);
        }
        else if (lang_1.isPresent(url = directive.template.templateUrl)) {
            var fileName = this.urlResolver.resolve(declFileName, url);
            var snapshot = this.host.getScriptSnapshot(fileName);
            if (!snapshot) {
                //try absolute path
                fileName = this.urlResolver.resolve(this.basePath + "/", url);
                snapshot = this.host.getScriptSnapshot(fileName);
                if (snapshot) {
                    //show warning that absolute paths are discouraged
                    this.addDiagnostic(decorator, "templateUrl", true, "Usage of absolute path is discouraged. Some packaging systems, like WebPack, work only with relative paths.", types_1.DiagnosticKind.Warning);
                }
                else {
                    //show error that template is not found
                    this.addDiagnostic(decorator, "templateUrl", true, "File " + this.urlResolver.resolve(declFileName, url).substring(8) + " does not exist.", types_1.DiagnosticKind.Error);
                }
            }
        }
        else if (lang_1.isPresent(template = directive.template.template)) {
            if (template.length < 50 && template.endsWith(".html")) {
                var fileName = this.urlResolver.resolve(declFileName, template);
                var snapshot = this.host.getScriptSnapshot(fileName);
                if (snapshot) {
                    this.addDiagnostic(decorator, "template", false, "It looks like you're referencing an existing template file. Did you want to use 'templateUrl' attribute?", types_1.DiagnosticKind.Warning);
                }
                else {
                    fileName = this.urlResolver.resolve(this.basePath + "/", template);
                    snapshot = this.host.getScriptSnapshot(fileName);
                    if (snapshot) {
                        this.addDiagnostic(decorator, "template", false, "It looks like you're referencing an existing template file. Did you want to use 'templateUrl' attribute?", types_1.DiagnosticKind.Warning);
                    }
                }
            }
        }
        else if (!templateProp && !templateUrlProp) {
            this.addDiagnostic(decorator, null, false, "No template specified for the component.", types_1.DiagnosticKind.Error);
        }
    };
    TypeScriptFileValidator.prototype.addDiagnostic = function (decorator, attr, initializer, message, kind) {
        this.result.push({
            message: message,
            kind: kind,
            span: attr
                ? this.findSpan(decorator, attr, initializer)
                : {
                    start: decorator.expression.expression.pos,
                    end: decorator.expression.expression.end
                }
        });
    };
    TypeScriptFileValidator.prototype.findSpan = function (decorator, attrib, initializer) {
        var prop = findProperty(decorator, attrib);
        if (prop) {
            if (initializer && prop.initializer) {
                return this.createSpan(prop.initializer.pos, prop.initializer.end);
            }
            else {
                return this.createSpan(prop.name.pos, prop.name.end);
            }
        }
        return null;
    };
    TypeScriptFileValidator.prototype.createSpan = function (start, end) {
        var char;
        while (start < end
            && (char = this.source.text.charAt(start))
            && (char === " " || char === "\t" || char === "\n" || char === "\r")) {
            start++;
        }
        return { start: start, end: end };
    };
    return TypeScriptFileValidator;
}());
exports.TypeScriptFileValidator = TypeScriptFileValidator;
function findDecorator(directive, declaration) {
    if (!declaration || !declaration.decorators) {
        return;
    }
    var decName = directive.isComponent ? "Component" : "Directive";
    return declaration.decorators
        .find(function (dec) { return dec
        && dec.expression
        && dec.expression.expression
        && dec.expression.expression.text === decName; });
}
exports.findDecorator = findDecorator;
function findProperty(decorator, attrib) {
    if (!decorator || !decorator.expression) {
        return null;
    }
    var props;
    var expr = decorator.expression;
    if (expr.arguments
        && expr.arguments[0]
        && (props = expr.arguments[0].properties)) {
        return props.find(function (prop) { return prop.name && prop.name.getText() === attrib; });
    }
    return null;
}
exports.findProperty = findProperty;
//# sourceMappingURL=extras.js.map