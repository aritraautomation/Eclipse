"use strict";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var core_1 = require('@angular/core');
var lang_1 = require('../facade/lang');
var identifiers_1 = require('../identifiers');
var o = require('../output/output_ast');
var private_import_core_1 = require('../private_import_core');
var template_ast_1 = require('../template_parser/template_ast');
var identifier_util_1 = require('./identifier_util');
function writeToRenderer(view, boundProp, renderElement, renderValue, logBindingUpdate, securityContextExpression) {
    var updateStmts = [];
    var renderer = view.prop('renderer');
    renderValue = sanitizedValue(view, boundProp, renderValue, securityContextExpression);
    switch (boundProp.type) {
        case template_ast_1.PropertyBindingType.Property:
            if (logBindingUpdate) {
                updateStmts.push(o.importExpr(identifiers_1.createIdentifier(identifiers_1.Identifiers.setBindingDebugInfo))
                    .callFn([renderer, renderElement, o.literal(boundProp.name), renderValue])
                    .toStmt());
            }
            updateStmts.push(renderer
                .callMethod('setElementProperty', [renderElement, o.literal(boundProp.name), renderValue])
                .toStmt());
            break;
        case template_ast_1.PropertyBindingType.Attribute:
            renderValue =
                renderValue.isBlank().conditional(o.NULL_EXPR, renderValue.callMethod('toString', []));
            updateStmts.push(renderer
                .callMethod('setElementAttribute', [renderElement, o.literal(boundProp.name), renderValue])
                .toStmt());
            break;
        case template_ast_1.PropertyBindingType.Class:
            updateStmts.push(renderer
                .callMethod('setElementClass', [renderElement, o.literal(boundProp.name), renderValue])
                .toStmt());
            break;
        case template_ast_1.PropertyBindingType.Style:
            var strValue = renderValue.callMethod('toString', []);
            if (lang_1.isPresent(boundProp.unit)) {
                strValue = strValue.plus(o.literal(boundProp.unit));
            }
            renderValue = renderValue.isBlank().conditional(o.NULL_EXPR, strValue);
            updateStmts.push(renderer
                .callMethod('setElementStyle', [renderElement, o.literal(boundProp.name), renderValue])
                .toStmt());
            break;
        case template_ast_1.PropertyBindingType.Animation:
            throw new Error('Illegal state: Should not come here!');
    }
    return updateStmts;
}
exports.writeToRenderer = writeToRenderer;
function sanitizedValue(view, boundProp, renderValue, securityContextExpression) {
    if (boundProp.securityContext === core_1.SecurityContext.NONE) {
        return renderValue; // No sanitization needed.
    }
    if (!boundProp.needsRuntimeSecurityContext) {
        securityContextExpression =
            identifier_util_1.createEnumExpression(identifiers_1.Identifiers.SecurityContext, boundProp.securityContext);
    }
    if (!securityContextExpression) {
        throw new Error("internal error, no SecurityContext given " + boundProp.name);
    }
    var ctx = view.prop('viewUtils').prop('sanitizer');
    var args = [securityContextExpression, renderValue];
    return ctx.callMethod('sanitize', args);
}
function triggerAnimation(view, componentView, boundProp, boundOutputs, eventListener, renderElement, renderValue, lastRenderValue) {
    var detachStmts = [];
    var updateStmts = [];
    var animationName = boundProp.name;
    var animationFnExpr = componentView.prop('componentType').prop('animations').key(o.literal(animationName));
    // it's important to normalize the void value as `void` explicitly
    // so that the styles data can be obtained from the stringmap
    var emptyStateValue = o.literal(private_import_core_1.EMPTY_STATE);
    var unitializedValue = o.importExpr(identifiers_1.createIdentifier(identifiers_1.Identifiers.UNINITIALIZED));
    var animationTransitionVar = o.variable('animationTransition_' + animationName);
    updateStmts.push(animationTransitionVar
        .set(animationFnExpr.callFn([
        view, renderElement,
        lastRenderValue.equals(unitializedValue).conditional(emptyStateValue, lastRenderValue),
        renderValue.equals(unitializedValue).conditional(emptyStateValue, renderValue)
    ]))
        .toDeclStmt());
    detachStmts.push(animationTransitionVar
        .set(animationFnExpr.callFn([view, renderElement, lastRenderValue, emptyStateValue]))
        .toDeclStmt());
    var registerStmts = [];
    var animationStartMethodExists = boundOutputs.find(function (event) { return event.isAnimation && event.name == animationName && event.phase == 'start'; });
    if (animationStartMethodExists) {
        registerStmts.push(animationTransitionVar
            .callMethod('onStart', [eventListener.callMethod(o.BuiltinMethod.Bind, [view, o.literal(template_ast_1.BoundEventAst.calcFullName(animationName, null, 'start'))])])
            .toStmt());
    }
    var animationDoneMethodExists = boundOutputs.find(function (event) { return event.isAnimation && event.name == animationName && event.phase == 'done'; });
    if (animationDoneMethodExists) {
        registerStmts.push(animationTransitionVar
            .callMethod('onDone', [eventListener.callMethod(o.BuiltinMethod.Bind, [view, o.literal(template_ast_1.BoundEventAst.calcFullName(animationName, null, 'done'))])])
            .toStmt());
    }
    updateStmts.push.apply(updateStmts, registerStmts);
    detachStmts.push.apply(detachStmts, registerStmts);
    return { updateStmts: updateStmts, detachStmts: detachStmts };
}
exports.triggerAnimation = triggerAnimation;
//# sourceMappingURL=render_util.js.map