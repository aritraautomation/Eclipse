"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var compile_metadata_1 = require('../compile_metadata');
var util_1 = require('../util');
var static_symbol_1 = require('./static_symbol');
var STRIP_SRC_FILE_SUFFIXES = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
function serializeSummaries(host, summaryResolver, symbolResolver, symbols, types) {
    var serializer = new Serializer(host);
    // for symbols, we use everything except for the class metadata itself
    // (we keep the statics though), as the class metadata is contained in the
    // CompileTypeSummary.
    symbols.forEach(function (resolvedSymbol) { return serializer.addOrMergeSummary({ symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata }); });
    // Add summaries that are referenced by the given symbols (transitively)
    // Note: the serializer.symbols array might be growing while
    // we execute the loop!
    for (var processedIndex = 0; processedIndex < serializer.symbols.length; processedIndex++) {
        var symbol = serializer.symbols[processedIndex];
        if (!host.isSourceFile(symbol.filePath)) {
            var summary = summaryResolver.resolveSummary(symbol);
            if (!summary) {
                // some symbols might originate from a plain typescript library
                // that just exported .d.ts and .metadata.json files, i.e. where no summary
                // files were created.
                var resolvedSymbol = symbolResolver.resolveSymbol(symbol);
                if (resolvedSymbol) {
                    summary = { symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata };
                }
            }
            if (summary) {
                serializer.addOrMergeSummary(summary);
            }
        }
    }
    // Add type summaries.
    // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,
    // as the type summaries already contain the transitive data that they require
    // (in a minimal way).
    types.forEach(function (typeSummary) {
        serializer.addOrMergeSummary({ symbol: typeSummary.type.reference, metadata: { __symbolic: 'class' }, type: typeSummary });
        if (typeSummary.summaryKind === compile_metadata_1.CompileSummaryKind.NgModule) {
            var ngModuleSummary = typeSummary;
            ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach(function (id) {
                var symbol = id.reference;
                if (!host.isSourceFile(symbol.filePath)) {
                    serializer.addOrMergeSummary(summaryResolver.resolveSummary(symbol));
                }
            });
        }
    });
    return serializer.serialize();
}
exports.serializeSummaries = serializeSummaries;
function deserializeSummaries(symbolCache, json) {
    var deserializer = new Deserializer(symbolCache);
    return deserializer.deserialize(json);
}
exports.deserializeSummaries = deserializeSummaries;
function summaryFileName(fileName) {
    var fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');
    return fileNameWithoutSuffix + ".ngsummary.json";
}
exports.summaryFileName = summaryFileName;
var Serializer = (function (_super) {
    __extends(Serializer, _super);
    function Serializer(host) {
        _super.call(this);
        this.host = host;
        this.symbols = [];
        this.indexBySymbol = new Map();
        // This now contains a `__symbol: number` in the place of
        // StaticSymbols, but otherwise has the same shape as the original objects.
        this.processedSummaryBySymbol = new Map();
        this.processedSummaries = [];
    }
    Serializer.prototype.addOrMergeSummary = function (summary) {
        var symbolMeta = summary.metadata;
        if (symbolMeta && symbolMeta.__symbolic === 'class') {
            // For classes, we only keep their statics, but not the metadata
            // of the class itself as that has been captured already via other summaries
            // (e.g. DirectiveSummary, ...).
            symbolMeta = { __symbolic: 'class', statics: symbolMeta.statics };
        }
        var processedSummary = this.processedSummaryBySymbol.get(summary.symbol);
        if (!processedSummary) {
            processedSummary = this.processValue({ symbol: summary.symbol });
            this.processedSummaries.push(processedSummary);
            this.processedSummaryBySymbol.set(summary.symbol, processedSummary);
        }
        // Note: == by purpose to compare with undefined!
        if (processedSummary.metadata == null && symbolMeta != null) {
            processedSummary.metadata = this.processValue(symbolMeta);
        }
        // Note: == by purpose to compare with undefined!
        if (processedSummary.type == null && summary.type != null) {
            processedSummary.type = this.processValue(summary.type);
        }
    };
    Serializer.prototype.serialize = function () {
        var _this = this;
        return JSON.stringify({
            summaries: this.processedSummaries,
            symbols: this.symbols.map(function (symbol, index) {
                return {
                    __symbol: index,
                    name: symbol.name,
                    // We convert the source filenames tinto output filenames,
                    // as the generated summary file will be used when teh current
                    // compilation unit is used as a library
                    filePath: _this.host.getOutputFileName(symbol.filePath)
                };
            })
        });
    };
    Serializer.prototype.processValue = function (value) { return util_1.visitValue(value, this, null); };
    Serializer.prototype.visitOther = function (value, context) {
        if (value instanceof static_symbol_1.StaticSymbol) {
            var index = this.indexBySymbol.get(value);
            // Note: == by purpose to compare with undefined!
            if (index == null) {
                index = this.indexBySymbol.size;
                this.indexBySymbol.set(value, index);
                this.symbols.push(value);
            }
            return { __symbol: index };
        }
    };
    return Serializer;
}(util_1.ValueTransformer));
var Deserializer = (function (_super) {
    __extends(Deserializer, _super);
    function Deserializer(symbolCache) {
        _super.call(this);
        this.symbolCache = symbolCache;
    }
    Deserializer.prototype.deserialize = function (json) {
        var _this = this;
        var data = JSON.parse(json);
        this.symbols = data.symbols.map(function (serializedSymbol) { return _this.symbolCache.get(serializedSymbol.filePath, serializedSymbol.name); });
        return util_1.visitValue(data.summaries, this, null);
    };
    Deserializer.prototype.visitStringMap = function (map, context) {
        if ('__symbol' in map) {
            return this.symbols[map['__symbol']];
        }
        else {
            return _super.prototype.visitStringMap.call(this, map, context);
        }
    };
    return Deserializer;
}(util_1.ValueTransformer));
//# sourceMappingURL=summary_serializer.js.map