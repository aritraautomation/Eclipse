"use strict";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
var compiler_1 = require("@angular/compiler");
var language_services_1 = require("@angular/compiler-cli/src/language_services");
var completions_1 = require("./completions");
var extras_1 = require("./extras");
var html_info_1 = require("./html_info");
var types_1 = require("./types");
var utils_1 = require("./utils");
function getTemplateDiagnostics(fileName, astProvider, templates, results) {
    var _loop_1 = function (template) {
        var templateResults = results.get(template.fileName);
        if (!templateResults) {
            templateResults = [];
            results.set(template.fileName, templateResults);
        }
        var ast = astProvider.getTemplateAst(template, fileName);
        if (ast) {
            var errors_1 = false;
            if (ast.parseErrors && ast.parseErrors.length) {
                templateResults.push.apply(templateResults, extras_1.processAstErrors(ast.parseErrors).map(function (e) {
                    errors_1 = errors_1 || e.level === compiler_1.ParseErrorLevel.ERROR;
                    return ({
                        kind: e.level === compiler_1.ParseErrorLevel.ERROR ? types_1.DiagnosticKind.Error : types_1.DiagnosticKind.Warning,
                        span: utils_1.offsetSpan(utils_1.spanOf(e.span), template.span.start),
                        message: e.msg,
                        type: "parse-problem"
                    });
                }));
            }
            if (!errors_1 && ast.templateAst && ast.htmlAst) {
                var info = {
                    templateAst: ast.templateAst,
                    htmlAst: ast.htmlAst,
                    offset: template.span.start,
                    query: template.query,
                    members: template.members
                };
                var info2_1 = {
                    template: template,
                    htmlAst: (ast.htmlAst),
                    directive: (ast.directive),
                    directives: (ast.directives),
                    pipes: (ast.pipes),
                    templateAst: (ast.templateAst),
                    expressionParser: (ast.expressionParser)
                };
                var expressionDiagnostics = language_services_1.getTemplateExpressionDiagnostics(info, function (elementName, element) { return completions_1.getAttributeInfosForElement(info2_1, elementName, element); }, function (attrName) { return html_info_1.validateAttribute(attrName); });
                templateResults.push.apply(templateResults, expressionDiagnostics);
            }
            if (ast.errors) {
                templateResults.push.apply(templateResults, ast.errors.map(function (e) { return ({ kind: e.kind, span: e.span || template.span, message: e.message, type: e.type }); }));
            }
        }
    };
    for (var _i = 0, templates_1 = templates; _i < templates_1.length; _i++) {
        var template = templates_1[_i];
        _loop_1(template);
    }
}
exports.getTemplateDiagnostics = getTemplateDiagnostics;
function getDeclarationDiagnostics(declarations, modules) {
    var results = [];
    var directives = undefined;
    var _loop_2 = function (declaration) {
        var report = function (message, kind, span) {
            results.push({
                kind: kind || types_1.DiagnosticKind.Error,
                span: span || declaration.declarationSpan, message: message
            });
        };
        for (var _i = 0, _a = declaration.errors; _i < _a.length; _i++) {
            var error = _a[_i];
            report(error.message, types_1.DiagnosticKind.Error, error.span);
        }
        if (declaration.metadata) {
            if (declaration.metadata.isComponent) {
                if (!modules.ngModuleByPipeOrDirective.has(declaration.type)) {
                    report("Component '" + declaration.type.name + "' is not included in a module and will not be available inside a template. Consider adding it to a NgModule declaration", types_1.DiagnosticKind.Warning);
                }
            }
            else {
                if (!directives) {
                    directives = new Set();
                    modules.ngModules.forEach(function (module) {
                        module.declaredDirectives.forEach(function (directive) { directives.add(directive.reference); });
                    });
                }
                if (!directives.has(declaration.type)) {
                    report("Directive '" + declaration.type.name + "' is not included in a module and will not be available inside a template. Consider adding it to a NgModule declaration", types_1.DiagnosticKind.Warning);
                }
            }
        }
    };
    for (var _i = 0, declarations_1 = declarations; _i < declarations_1.length; _i++) {
        var declaration = declarations_1[_i];
        _loop_2(declaration);
    }
    return results;
}
exports.getDeclarationDiagnostics = getDeclarationDiagnostics;
//# sourceMappingURL=diagnostics.js.map