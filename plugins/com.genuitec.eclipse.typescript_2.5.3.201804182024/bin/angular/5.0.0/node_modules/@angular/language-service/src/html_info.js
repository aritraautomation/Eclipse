"use strict";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Information about the HTML DOM elements
Object.defineProperty(exports, "__esModule", { value: true });
var dom_schema = require("@angular/compiler/src/schema/dom_element_schema_registry");
// This is schemaInformation for HTML attributes, it is based on DOM element schema registry
var propToAttrMap = {
    'className': 'class',
    'classList': null,
    'formAction': 'formaction',
    'innerHTML': null,
    'innerText': null,
    'textContent': null,
    'readOnly': 'readonly',
    'tabIndex': 'tabindex',
    'htmlFor': 'for'
};
var EVENT = 'event';
var BOOLEAN = 'boolean';
var NUMBER = 'number';
var STRING = 'string';
var OBJECT = 'object';
var AttrSchemaInformation = (function () {
    function AttrSchemaInformation() {
        var _this = this;
        this.schema = {};
        dom_schema.SCHEMA.forEach(function (encodedType) {
            var type = {};
            var _a = encodedType.split('|'), strType = _a[0], strProperties = _a[1];
            var properties = strProperties.split(',');
            var _b = strType.split('^'), typeNames = _b[0], superName = _b[1];
            typeNames.split(',').forEach(function (tag) { return _this.schema[tag.toLowerCase()] = type; });
            var superType = superName && _this.schema[superName.toLowerCase()];
            if (superType) {
                Object.keys(superType).forEach(function (prop) { type[prop] = superType[prop]; });
            }
            //translate from DOM prop name to HTML attr name
            properties.forEach(function (property, index) {
                var attr = null;
                var prefix = "";
                switch (property[0]) {
                    case '*':
                    case '!':
                    case '#':
                    case '%':
                        prefix = property[0];
                        attr = propToAttrMap[property.substring(1)];
                        break;
                    default:
                        attr = propToAttrMap[property];
                }
                if (attr === null) {
                    properties[index] = attr;
                }
                else if (attr) {
                    properties[index] = prefix + attr;
                }
            });
            properties.forEach(function (property) {
                if (property && property.length > 0) {
                    property = property.toLowerCase();
                    switch (property[0]) {
                        case '*':
                            // We don't yet support events.
                            // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events
                            // will
                            // almost certainly introduce bad XSS vulnerabilities.
                            //type["on" + property.substring(1)] = EVENT;
                            break;
                        case '!':
                            type[property.substring(1)] = BOOLEAN;
                            break;
                        case '#':
                            type[property.substring(1)] = NUMBER;
                            break;
                        case '%':
                            type[property.substring(1)] = OBJECT;
                            break;
                        default:
                            type[property] = STRING;
                    }
                }
            });
        });
    }
    AttrSchemaInformation.prototype.attrsOf = function (elementName) {
        var elementType = this.schema[elementName.toLowerCase()]
            || this.schema["[htmlelement]"];
        return Object.keys(elementType).filter(function (property) { return elementType[property] !== EVENT; });
    };
    AttrSchemaInformation.prototype.typeOf = function (elementName, attr) {
        return (this.schema[elementName.toLowerCase()] || {})[attr.toLowerCase()];
    };
    Object.defineProperty(AttrSchemaInformation, "instance", {
        get: function () {
            var result = AttrSchemaInformation._instance;
            if (!result) {
                result = AttrSchemaInformation._instance = new AttrSchemaInformation();
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    return AttrSchemaInformation;
}());
var propertyRegistry = new dom_schema.DomElementSchemaRegistry();
function elementNames() {
    return Object.keys(AttrSchemaInformation.instance.schema).sort().map(function (v) { return v.toLowerCase(); });
}
exports.elementNames = elementNames;
function attributeNames(elementName) {
    return AttrSchemaInformation.instance.attrsOf(elementName);
}
exports.attributeNames = attributeNames;
function attributeType(element, attribute) {
    return AttrSchemaInformation.instance.typeOf(element, attribute);
}
exports.attributeType = attributeType;
function eventNames(elementName) {
    var elementType = propertyRegistry["_schema"][elementName.toLowerCase()] || {};
    return Object.keys(elementType).filter(function (property) { return elementType[property] === EVENT; });
}
exports.eventNames = eventNames;
function propertyNames(elementName) {
    var elementType = propertyRegistry["_schema"][elementName.toLowerCase()] || {};
    return Object.keys(elementType).filter(function (property) { return elementType[property] !== EVENT; });
}
exports.propertyNames = propertyNames;
function propertyType(elementName, propertyName) {
    return (propertyRegistry["_schema"][elementName.toLowerCase()] || {})[propertyName];
}
exports.propertyType = propertyType;
function validateAttribute(name) {
    var _a = propertyRegistry.validateAttribute(name), error = _a.error, msg = _a.msg;
    if (error) {
        return msg;
    }
}
exports.validateAttribute = validateAttribute;
//# sourceMappingURL=html_info.js.map